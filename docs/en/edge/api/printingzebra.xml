<?xml version = "1.0"?>
<?xml-stylesheet type="text/xsl" href="pb_help.xsl"?>
<API>
    <MODULE name="PrinterZebra" parent="Rho">
        <HELP_OVERVIEW>The Printer Module provides access to find, connect, and print to Bluetooth and WiFi Network printers.</HELP_OVERVIEW>
        <MORE_HELP>Zebra specific API support

To use bluetooth connection on iOS devices you should take into account following preconditions:

* It will only work with Zebra printers which have the Made For iPod/iPhone certification.
* Before using printer you should pair it using system bluetooth settings.
* You need to include the External Accessory framework in your project (will be automatically added when iPhone project file is generated)
* You need to include the Zebra printer protocol string "com.zebra.rawport" in your info.plist file ([project root]/project/iphone/Info.plist) under "Supported external accessory protocols":
        &lt;key&gt;UISupportedExternalAccessoryProtocols&lt;/key&gt;
        &lt;array&gt;
            &lt;string&gt;com.zebra.rawport&lt;/string&gt;
        &lt;/array&gt;
* You need to Set the key "Required Background modes" to "App Communicates with an accessory" in your app's plist file
        &lt;key&gt;UIBackgroundModes&lt;/key&gt;
        &lt;array&gt;
            &lt;string&gt;external-accessory&lt;/string&gt;
        &lt;/array&gt;

Android platform specific:

* When you call searchPrinters() with Bluetooth search (with CONNECTION_TYPE_ANY or CONNECTION_TYPE_BLUETOOTH) then Zebra SDK enumerate _all_ Bluetooth devices around and you can see a lot of pairing request to non-printer devices too. Just cancel them. This produced because we can not detect printer before real connection to device, but real connection require pairing.

Windows Mobile/CE note:

* Requires a Printing Service application to be running. This is described in the [Printing Guide](../guide/printing#platform-notes)

## Enabling the API
In order to use this API you must include the following extension in your `build.yml`.
    :::ruby
    extensions: ["printing","printing_zebra"]

NOTE: If you are building a Windows Mobile or Windows CE app with this API, you must set your app_type as "rhoelements" in your build.yml as shown [here](../guide/build_config#other-build-time-settings).

NOTE: If you are building a Windows Mobile or Windows CE app with this API, you must avoid from leaving page without disconnecting from connected printer. Right way for it is using window.onunload event window.onunload = function(){printer.docsconnect()}

## JavaScript Usage
Be sure to review the [JavaScript API Usage](/guide/api_js) guide for important information about using this API in JavaScript.

## Ruby Usage
Be sure to review the [Ruby API Usage](/guide/api_ruby) guide for important information about using this API in Ruby.
        </MORE_HELP>

        <TEMPLATES>
            <DEFAULT_INSTANCE/>
            <PROPERTY_BAG/>
            <SINGLETON_INSTANCES/>
            <INCLUDE path="../../printing/ext/printing.xml"/>
        </TEMPLATES>

        <CONSTANTS>
            <!-- Zebra specific properties -->
            <CONSTANT name="PRINT_MODE_APPLICATOR" value="PRINT_MODE_APPLICATOR" type="STRING">
                <DESC>Applicator print mode</DESC>
            </CONSTANT>
            <CONSTANT name="PRINT_MODE_CUTTER" value="PRINT_MODE_CUTTER" type="STRING">
                <DESC>Cutter print mode</DESC>
            </CONSTANT>
            <CONSTANT name="PRINT_MODE_DELAYED_CUT" value="PRINT_MODE_DELAYED_CUT" type="STRING">
                <DESC>Delayed cut print mode</DESC>
            </CONSTANT>
            <CONSTANT name="PRINT_MODE_KIOSK" value="PRINT_MODE_KIOSK" type="STRING">
                <DESC>Kiosk print mode</DESC>
            </CONSTANT>
            <CONSTANT name="PRINT_MODE_LINERLESS_PEEL" value="PRINT_MODE_LINERLESS_PEEL" type="STRING">
                <DESC>Linerless peel print mode</DESC>
            </CONSTANT>
            <CONSTANT name="PRINT_MODE_LINERLESS_REWIND" value="PRINT_MODE_LINERLESS_REWIND" type="STRING">
                <DESC>Linerless rewind print mode</DESC>
            </CONSTANT>
            <CONSTANT name="PRINT_MODE_PARTIAL_CUTTER" value="PRINT_MODE_PARTIAL_CUTTER" type="STRING">
                <DESC>Partial cutter print mode</DESC>
            </CONSTANT>
            <CONSTANT name="PRINT_MODE_PEEL_OFF" value="PRINT_MODE_PEEL_OFF" type="STRING">
                <DESC>Peel-off print mode</DESC>
            </CONSTANT>
            <CONSTANT name="PRINT_MODE_REWIND" value="PRINT_MODE_REWIND" type="STRING">
                <DESC>Rewind print mode</DESC>
            </CONSTANT>
            <CONSTANT name="PRINT_MODE_RFID" value="PRINT_MODE_RFID" type="STRING">
                <DESC>RFID print mode</DESC>
            </CONSTANT>
            <CONSTANT name="PRINT_MODE_TEAR_OFF" value="PRINT_MODE_TEAR_OFF" type="STRING">
                <DESC>Tear-off print mode (this also implies Linerless Tear print mode)</DESC>
            </CONSTANT>
            <CONSTANT name="PRINT_MODE_UNKNOWN" value="PRINT_MODE_UNKNOWN" type="STRING">
                <DESC>Unknown print mode</DESC>
            </CONSTANT>


            <!-- Connection types types -->
            <CONSTANT name="DISCOVERY_MODE_MULTICAST" value="DISCOVERY_MODE_MULTICAST" type="STRING"/>
            <CONSTANT name="DISCOVERY_MODE_SUBNET_SEARCH" value="DISCOVERY_MODE_SUBNET_SEARCH" type="STRING"/>
            <CONSTANT name="DISCOVERY_MODE_DIRECTED_BROADCAST" value="DISCOVERY_MODE_DIRECTED_BROADCAST" type="STRING"/>
            <CONSTANT name="DISCOVERY_MODE_LOCAL_BROADCAST" value="DISCOVERY_MODE_LOCAL_BROADCAST" type="STRING"/>


            <CONSTANT name="ERROR_NO_CONNECTION" value="ERROR_NO_CONNECTION" type="STRING">
                <DESC>Unable to create a connection to a printer</DESC>
            </CONSTANT>

            <CONSTANT name="ERROR_WRITE_FAILURE" value="ERROR_WRITE_FAILURE" type="STRING">
                <DESC>Write to a connection failed</DESC>
            </CONSTANT>

            <CONSTANT name="ERROR_READ_FAILURE" value="ERROR_READ_FAILURE" type="STRING">
                <DESC>Read from a connection failed</DESC>
            </CONSTANT>

            <CONSTANT name="ERROR_UNKNOWN_PRINTER_LANGUAGE" value="ERROR_UNKNOWN_PRINTER_LANGUAGE" type="STRING">
                <DESC>Unable to determine the control language of a printer</DESC>
            </CONSTANT>

            <CONSTANT name="ERROR_MALFORMED_NETWORK_DISCOVERY_ADDRESS" value="ERROR_MALFORMED_NETWORK_DISCOVERY_ADDRESS" type="STRING">
                <DESC>Malformed discovery address</DESC>
            </CONSTANT>

            <CONSTANT name="ERROR_NETWORK_ERROR_DURING_DISCOVERY" value="ERROR_NETWORK_ERROR_DURING_DISCOVERY" type="STRING">
                <DESC>Network error during discovery</DESC>
            </CONSTANT>

            <CONSTANT name="ERROR_INVALID_DISCOVERY_HOP_COUNT" value="ERROR_INVALID_DISCOVERY_HOP_COUNT" type="STRING">
                <DESC>Invalid multicast hop count</DESC>
            </CONSTANT>

            <CONSTANT name="ERROR_MALFORMED_PRINTER_STATUS_RESPONSE" value="ERROR_MALFORMED_PRINTER_STATUS_RESPONSE" type="STRING">
                <DESC>Malformed status response - unable to determine printer status</DESC>
            </CONSTANT>

            <CONSTANT name="ERROR_INVALID_FORMAT_NAME" value="ERROR_INVALID_FORMAT_NAME" type="STRING">
                <DESC>Invalid format name</DESC>
            </CONSTANT>

            <CONSTANT name="ERROR_BAD_FILE_DIRECTORY_ENTRY" value="ERROR_BAD_FILE_DIRECTORY_ENTRY" type="STRING">
                <DESC>Bad file directory entry</DESC>
            </CONSTANT>

            <CONSTANT name="ERROR_MALFORMED_FORMAT_FIELD_NUMBER" value="ERROR_MALFORMED_FORMAT_FIELD_NUMBER" type="STRING">
                <DESC>'^FN' integer must be between 1 and 999</DESC>
            </CONSTANT>

            <CONSTANT name="ERROR_INVALID_PRINTER_LANGUAGE" value="ERROR_INVALID_PRINTER_LANGUAGE" type="STRING">
                <DESC>Invalid printer language</DESC>
            </CONSTANT>

            <CONSTANT name="ERROR_INVALID_FILE_NAME" value="ERROR_INVALID_FILE_NAME" type="STRING">
                <DESC>Invalid file name</DESC>
            </CONSTANT>

            <CONSTANT name="ERROR_INVALID_PRINTER_DRIVE_LETTER" value="ERROR_INVALID_PRINTER_DRIVE_LETTER" type="STRING">
                <DESC>Invalid drive specified</DESC>
            </CONSTANT>
            
            <CONSTANT name="PRINTER_STATE_IS_HEAD_COLD" value="PRINTER_STATE_IS_HEAD_COLD" type="STRING">
                <DESC>use this name for requestState(), true if the head is cold</DESC>
            </CONSTANT>
            <CONSTANT name="PRINTER_STATE_IS_HEAD_OPEN" value="PRINTER_STATE_IS_HEAD_OPEN" type="STRING">
                <DESC>use this name for requestState(), true if the head is open</DESC>
            </CONSTANT>
            <CONSTANT name="PRINTER_STATE_IS_HEAD_TOO_HOT" value="PRINTER_STATE_IS_HEAD_TOO_HOT" type="STRING">
                <DESC>use this name for requestState(), true if the head is too hot</DESC>
            </CONSTANT>
            <CONSTANT name="PRINTER_STATE_IS_PARTIAL_FORMAT_IN_PROGRESS" value="PRINTER_STATE_IS_PARTIAL_FORMAT_IN_PROGRESS" type="STRING">
                <DESC>use this name for requestState(), true if there is a partial format in progress</DESC>
            </CONSTANT>
            <CONSTANT name="PRINTER_STATE_IS_PAUSED" value="PRINTER_STATE_IS_PAUSED" type="STRING">
                <DESC>use this name for requestState(), true if the printer is paused</DESC>
            </CONSTANT>
            <CONSTANT name="PRINTER_STATE_IS_RECEIVE_BUFFER_FULL" value="PRINTER_STATE_IS_RECEIVE_BUFFER_FULL" type="STRING">
                <DESC>use this name for requestState(), true if the receive buffer is full</DESC>
            </CONSTANT>
            <CONSTANT name="PRINTER_STATE_IS_RIBBON_OUT" value="PRINTER_STATE_IS_RIBBON_OUT" type="STRING">
                <DESC>use this name for requestState(), true if the ribbon is out</DESC>
            </CONSTANT>
            <CONSTANT name="PRINTER_STATE_LABEL_LENGTH_IN_DOTS" value="PRINTER_STATE_LABEL_LENGTH_IN_DOTS" type="STRING">
                <DESC>use this name for requestState(), The length of the label in dots</DESC>
            </CONSTANT>
            <CONSTANT name="PRINTER_STATE_LABELS_REMAINING_IN_BATCH" value="PRINTER_STATE_LABELS_REMAINING_IN_BATCH" type="STRING">
                <DESC>use this name for requestState(), The number of labels remaining in the batch</DESC>
            </CONSTANT>
            <CONSTANT name="PRINTER_STATE_NUMBER_OF_FORMATS_IN_RECEIVE_BUFFER" value="PRINTER_STATE_NUMBER_OF_FORMATS_IN_RECEIVE_BUFFER" type="STRING">
                <DESC>use this name for requestState(), The number of formats currently in the receive buffer of the printer</DESC>
            </CONSTANT>
            <CONSTANT name="PRINTER_STATE_PRINT_MODE" value="PRINTER_STATE_PRINT_MODE" type="STRING">
                <DESC>use this name for requestState(), The print mode</DESC>
            </CONSTANT>
        </CONSTANTS>

        <METHODS access="INSTANCE">            
            <METHOD name="retrieveFileNames" hasCallback="mandatory">
                <DESC>Retrieves the names of the files which are stored on the printer. Works asynchronously, use callback to check the result.</DESC>
                <CALLBACK type="HASH">
                    <PARAMS>
                        <PARAM name="status" type="STRING">
                            <DESC>PRINTER_STATUS_SUCCESS, PRINTER_STATUS_ERROR</DESC>
                        </PARAM>
                        <PARAM name="fileNames" type="ARRAY">
                            <PARAM type="STRING"></PARAM>
                            <DESC></DESC>
                        </PARAM>
                    </PARAMS>
                </CALLBACK>
                <PLATFORM>WM, Android, iOS</PLATFORM> 
            </METHOD>

            <METHOD name="retrieveFileNamesWithExtensions" hasCallback="mandatory">
                <DESC>This method only returns files which have the extensions in "extensions". Works asynchronously, use callback to check the result.</DESC>
                <PARAMS>
                    <PARAM name="extensions" type="ARRAY">
                        <PARAM type="STRING"></PARAM>
                        <DESC>The list of extensions that should be returned.</DESC>
                    </PARAM>
                </PARAMS>
                <CALLBACK type="HASH">
                    <PARAMS>
                        <PARAM name="status" type="STRING">
                            <DESC>PRINTER_STATUS_SUCCESS, PRINTER_STATUS_ERROR</DESC>
                        </PARAM>
                        <PARAM name="fileNames" type="ARRAY">
                            <PARAM type="STRING"></PARAM>
                            <DESC></DESC>
                        </PARAM>
                    </PARAMS>
                </CALLBACK>
                <PLATFORM>WM, Android, iOS</PLATFORM> 
            </METHOD>

            <METHOD name="sendFileContents" hasCallback="optional">
                <DESC>Sends the contents of a file on the device to the printer. Equals to printing raw string with content of specified file. Should be used to print ZPL and CPCL commands stored inside predefined filed. Works asynchronously, use callback to check the result.</DESC>
                <PARAMS>
                    <PARAM name="path" type="STRING">
                        <DESC>Location of file to print. This path must be fully qualified path to local file on the device.</DESC>
                    </PARAM>
                </PARAMS>
                <CALLBACK type="STRING">
                    <DESC>Returns result of a printing attempt. PRINTER_STATUS_SUCCESS, PRINTER_STATUS_ERROR</DESC>
                </CALLBACK>
                <PLATFORM>WM, Android, iOS</PLATFORM> 
            </METHOD>

            <METHOD name="printStoredFormatWithHash" hasCallback="optional">
                <DESC>Prints a stored format on the printer, filling in the fields specified by the Hash. Works asynchronously, use callback to check the result.</DESC>
                <PARAMS>
                    <PARAM name="formatPathOnPrinter" type="STRING">
                        <DESC>The location of the file on the printer (e.g. "E:FORMAT.ZPL").</DESC>
                    </PARAM>
                    <PARAM name="vars" type="HASH">
                        <DESC>An Hash which contains the key/value pairs for the stored format. For ZPL formats, the key number should correspond directly to the number of the field in the format. Number keys should be passed as String: '1':'field1' etc. CPCL format do not supported - only ZPL!</DESC>
                    </PARAM>
                </PARAMS>
                <CALLBACK type="STRING">
                    <DESC>Returns result of a printing attempt. PRINTER_STATUS_SUCCESS, PRINTER_STATUS_ERROR. If you try to print format contains invalid data, then only iOS return ERROR, on Android and WM  Zebra SDK not provided that info due to Zebra SDK API limitations on Android and WM. So on Android and WM you can receive ERROR only if some connection problem occured.</DESC>
                </CALLBACK>
                <PLATFORM>Android, iOS</PLATFORM> 
            </METHOD>

            <METHOD name="printStoredFormatWithArray" hasCallback="optional">
                <DESC>Prints a stored format on the printer, filling in the fields specified by the array. Works asynchronously, use callback to check the result.</DESC>
                <PARAMS>
                    <PARAM name="formatPathOnPrinter" type="STRING">
                        <DESC>The location of the file on the printer (e.g. "E:FORMAT.ZPL").</DESC>
                    </PARAM>
                    <PARAM name="vars" type="Array">
                        <DESC>An array of strings representing the data to fill into the format. For ZPL formats, index 0 of the array corresponds to field number 2 (^FN2). For CPCL, the variables are passed in the order that they are found in the format</DESC>
                    </PARAM>
                </PARAMS>
                <CALLBACK type="STRING">
                    <DESC>Returns result of a printing attempt. PRINTER_STATUS_SUCCESS, PRINTER_STATUS_ERROR. If you try to print format contains invalid data, then only iOS return ERROR, on Android and WM  Zebra SDK not provided that info due to Zebra SDK API limitations on Android and WM. So on Android and WM you can receive ERROR only if some connection problem occured. </DESC>
                </CALLBACK>
                <PLATFORM>WM, Android, iOS</PLATFORM> 
            </METHOD>

            <METHOD name="storeImage" hasCallback="optional">
                <DESC>Stores the specified image to the connected printer as a monochrome image. Works asynchronously, use callback to check the result. The image will be stored on the printer at printerDriveAndFileName with the extension GRF. If a drive letter is not supplied, E will be used as the default (e.g. FILE becomes E:FILE.GRF). If an extension is supplied, it is ignored (E:FILE.BMP becomes E:FILE.GRF). Note: if the image resolution is large (e.g. 1024x768) this method may take a long time to execute. There are device OS limitations on supported file formats and image sizes. iOS is supporting only JPG and PNG files. WM can fail to handle large (>1024x1024 pixel) images.</DESC>
                <PARAMS>
                    <PARAM name="printerDriveAndFileName" type="STRING">
                        <DESC>Path on the printer where the image will be stored.</DESC>
                    </PARAM>
                    <PARAM name="imageFilePathOnDevice" type="STRING">
                        <DESC>Path to the local image file containing the bitmap image to send.</DESC>
                    </PARAM>
                    <PARAM name="width" type="INTEGER">
                        <DESC>Desired width of the printed image, in dots. Passing -1 will preserve original width.</DESC>
                    </PARAM>
                    <PARAM name="height" type="INTEGER">
                        <DESC>Desired height of the printed image, in dots. Passing -1 will preserve original height.</DESC>
                    </PARAM>
                </PARAMS>
                <CALLBACK type="STRING">
                    <DESC>Returns result of a printing attempt. PRINTER_STATUS_SUCCESS, PRINTER_STATUS_ERROR, </DESC>
                </CALLBACK>
                <PLATFORM>WM, Android, iOS</PLATFORM> 
            </METHOD>
        </METHODS>

        <USER_OVERVIEW>
        </USER_OVERVIEW>

        <VER_INTRODUCED>1.0.0</VER_INTRODUCED>

        <PLATFORM>
        </PLATFORM>

        <EXAMPLES>
            <EXAMPLE title="Printing via Bluetooth">
                <SECTIONS>
                    <SECTION>
                        <DESC>To print to the Zebra printer we must first search for the device. In this example we are using the searchPrinters method and passing in options to limit the search to Bluetooth and also look for Zebra printers only. If we knew the printer Bluetooth address we could have added the 'deviceAddress' parameter. The callback function will be executed for each printer found. When a printer is found the callback object will contain a 'printerID' property. This ID is an internal RhoMobie ID used. If no printerID property is there for the successful callback object, then it means that the search has finished.</DESC>
                        <CODE>
                            <JAVASCRIPT>
           <![CDATA[
var printers = [];

Rho.PrinterZebra.searchPrinters({ 
    connectionType:Rho.PrinterZebra.CONNECTION_TYPE_BLUETOOTH,  
    printerType: Rho.PrinterZebra.PRINTER_TYPE_ZEBRA
    }, function (cb){
        if(cb.status == 'PRINTER_STATUS_SUCCESS')
        {
            if (typeof cb.printerID != "undefined")
            {
                console.log('Found: ' + cb.printerID)
                printers.push(cb.printerID);
            }
            else
            {
                console.log('Done Searching');
            }
        }
        else
        {
            console.log(cb.status);
        }
    }
);
                   ]]>
                            </JAVASCRIPT>
                        </CODE>
                    </SECTION>
                    <SECTION>
                        <DESC>Now that we have found a printer. The `printers` array will contain the `printerID` we need to create an instance object that we will use for all communications. Upon first connection to the printer via Bluetooth, you may see a prompt to enter the Bluetooth PIN. Check the manufacturers guide for details. Normally the defaul is '0000' or '1111' or '1234'. Once it is connected, you should see some indication in the printer (like a blue light).</DESC>
                        <CODE>
                            <JAVASCRIPT>
           <![CDATA[
var myPrinter = Rho.PrinterZebra.getPrinterByID(printers[0]);

// Let's try connecting
myPrinter.connect(function (cb){
    console.log(cb);
    // This will be the Zebra's `Friendly Name` 
    // by default it is the serial number
    console.log(myPrinter.deviceName);

    // This will be the BT MC Address 
    since we are connecting via BlueTooth
    console.log(myPrinter.deviceAddress);
});
                   ]]>
                            </JAVASCRIPT>
                        </CODE>
                    </SECTION>
                    <SECTION>
                        <DESC>Now we can just print a test string and read some properties of the printer to make sure the communications is working.</DESC>
                        <CODE>
                            <JAVASCRIPT>
           <![CDATA[
// If my printer was in line mode I would see this text printed
myPrinter.printRawString('This is a test print');

// Example of sending a Zebra CPCL Command
// changing from linemode to ZPL mode
myPrinter.printRawString('! U1 setvar "device.languages" "ZPL"\r\n');

//Get state - this is realtime status of printer
// reading a property of the myPrinter instance will
// show last known status
myPrinter.requestState(['PRINTER_STATE_IS_READY_TO_PRINT',
    'PRINTER_STATE_IS_PAPER_OUT'],function (cb){
        console.log(cb.status);
        console.log(cb.PRINTER_STATE_IS_PAPER_OUT);
        console.log(cb.PRINTER_STATE_IS_READY_TO_PRINT);

    });
                   ]]>
                            </JAVASCRIPT>
                        </CODE>
                    </SECTION>
                </SECTIONS>
            </EXAMPLE>
        </EXAMPLES>
    </MODULE>
</API>
