<?xml version = "1.0"?>
<?xml-stylesheet type="text/xsl" href="pb_help.xsl"?>
<API>
    <MODULE name="PrinterZebra" parent="Rho">
        <HELP_OVERVIEW>The Printer Module provides access to find, connect, and print to Bluetooth and WiFi Network printers.</HELP_OVERVIEW>
        <MORE_HELP>Zebra specific API support

To use bluetooth connection on iOS devices you should take into account following preconditions:

* It will only work with Zebra printers which have the Made For iPod/iPhone certification.
* Before using printer you should pair it using system bluetooth settings.
* You need to include the External Accessory framework in your project (will be automatically added when iphone project file is generated)
* You need to include the Zebra printer protocol string "com.zebra.rawport" in your info.plist file ([project root]/project/iphone/Info.plist) under "Supported external accessory protocols":
        &lt;key&gt;UISupportedExternalAccessoryProtocols&lt;/key&gt;
        &lt;array&gt;
            &lt;string&gt;com.zebra.rawport&lt;/string&gt;
        &lt;/array&gt;
* You need to Set the key "Required Background modes" to "App Communicates with an accessory" in your app's plist file
        &lt;key&gt;UIBackgroundModes&lt;/key&gt;
        &lt;array&gt;
            &lt;string&gt;external-accessory&lt;/string&gt;
        &lt;/array&gt;

Android platfrom specific:

* When you call searchPrinters() with Bluetooth search (with CONNECTION_TYPE_ANY or CONNECTION_TYPE_BLUETOOTH) then Zebra SDK enumerate _all_ Bluetooth devices around and you can see a lot of pairing request to non-printer devices too. Just cancel them. This produced because we can not detect printer before real connection to device, but real connection require pairing :-).

## Enabling the API
In order to use this API you must include the following extension in your `build.yml`
    :::ruby
    extensions: ["printing_zebra"]

The `printing_zebra` extension is also included automatically if you specify the following in your `build.yml`
    :::ruby
    app_type: "rhoelements"

**NOTE: If you are building a Windows Mobile or Windows CE app with this API, you must set your app_type as "rhoelements" in your build.yml as shown [here](../guide/build_config#other-build-time-settings).**

## JavaScript Usage
Be sure to review the [JavaScript API Usage](/guide/api_js) guide for important information about using this API in JavaScript

## Ruby Usage
Be sure to review the [Ruby API Usage](/guide/api_ruby) guide for important information about using this API in Ruby

        </MORE_HELP>
    
        <TEMPLATES>
            <DEFAULT_INSTANCE/>
            <PROPERTY_BAG/>
            <SINGLETON_INSTANCES/>
            <INCLUDE path="../../printing/ext/printing.xml"/>
        </TEMPLATES>

        <CONSTANTS>
            <!-- Zebra specific properties -->
            <CONSTANT name="PRINT_MODE_APPLICATOR" value="PRINT_MODE_APPLICATOR" type="STRING">
                <DESC>Applicator print mode</DESC>
            </CONSTANT>
            <CONSTANT name="PRINT_MODE_CUTTER" value="PRINT_MODE_CUTTER" type="STRING">
                <DESC>Cutter print mode</DESC>
            </CONSTANT>
            <CONSTANT name="PRINT_MODE_DELAYED_CUT" value="PRINT_MODE_DELAYED_CUT" type="STRING">
                <DESC>Delayed cut print mode</DESC>
            </CONSTANT>
            <CONSTANT name="PRINT_MODE_KIOSK" value="PRINT_MODE_KIOSK" type="STRING">
                <DESC>Kiosk print mode</DESC>
            </CONSTANT>
            <CONSTANT name="PRINT_MODE_LINERLESS_PEEL" value="PRINT_MODE_LINERLESS_PEEL" type="STRING">
                <DESC>Linerless peel print mode</DESC>
            </CONSTANT>
            <CONSTANT name="PRINT_MODE_LINERLESS_REWIND" value="PRINT_MODE_LINERLESS_REWIND" type="STRING">
                <DESC>Linerless rewind print mode</DESC>
            </CONSTANT>
            <CONSTANT name="PRINT_MODE_PARTIAL_CUTTER" value="PRINT_MODE_PARTIAL_CUTTER" type="STRING">
                <DESC>Partial cutter print mode</DESC>
            </CONSTANT>
            <CONSTANT name="PRINT_MODE_PEEL_OFF" value="PRINT_MODE_PEEL_OFF" type="STRING">
                <DESC>Peel-off print mode</DESC>
            </CONSTANT>
            <CONSTANT name="PRINT_MODE_REWIND" value="PRINT_MODE_REWIND" type="STRING">
                <DESC>Rewind print mode</DESC>
            </CONSTANT>
            <CONSTANT name="PRINT_MODE_RFID" value="PRINT_MODE_RFID" type="STRING">
                <DESC>RFID print mode</DESC>
            </CONSTANT>
            <CONSTANT name="PRINT_MODE_TEAR_OFF" value="PRINT_MODE_TEAR_OFF" type="STRING">
                <DESC>Tear-off print mode (this also implies Linerless Tear print mode)</DESC>
            </CONSTANT>
            <CONSTANT name="PRINT_MODE_UNKNOWN" value="PRINT_MODE_UNKNOWN" type="STRING">
                <DESC>Unknown print mode</DESC>
            </CONSTANT>


            <!-- Connection types types -->
            <CONSTANT name="DISCOVERY_MODE_MULTICAST" value="DISCOVERY_MODE_MULTICAST" type="STRING"/>
            <CONSTANT name="DISCOVERY_MODE_SUBNET_SEARCH" value="DISCOVERY_MODE_SUBNET_SEARCH" type="STRING"/>
            <CONSTANT name="DISCOVERY_MODE_DIRECTED_BROADCAST" value="DISCOVERY_MODE_DIRECTED_BROADCAST" type="STRING"/>
            <CONSTANT name="DISCOVERY_MODE_LOCAL_BROADCAST" value="DISCOVERY_MODE_LOCAL_BROADCAST" type="STRING"/>


            <CONSTANT name="ERROR_NO_CONNECTION" value="ERROR_NO_CONNECTION" type="STRING">
                <DESC>Unable to create a connection to a printer</DESC>
            </CONSTANT>

            <CONSTANT name="ERROR_WRITE_FAILURE" value="ERROR_WRITE_FAILURE" type="STRING">
                <DESC>Write to a connection failed</DESC>
            </CONSTANT>

            <CONSTANT name="ERROR_READ_FAILURE" value="ERROR_READ_FAILURE" type="STRING">
                <DESC>Read from a connection failed</DESC>
            </CONSTANT>

            <CONSTANT name="ERROR_UNKNOWN_PRINTER_LANGUAGE" value="ERROR_UNKNOWN_PRINTER_LANGUAGE" type="STRING">
                <DESC>Unable to determine the control language of a printer</DESC>
            </CONSTANT>

            <CONSTANT name="ERROR_MALFORMED_NETWORK_DISCOVERY_ADDRESS" value="ERROR_MALFORMED_NETWORK_DISCOVERY_ADDRESS" type="STRING">
                <DESC>Malformed discovery address</DESC>
            </CONSTANT>

            <CONSTANT name="ERROR_NETWORK_ERROR_DURING_DISCOVERY" value="ERROR_NETWORK_ERROR_DURING_DISCOVERY" type="STRING">
                <DESC>Network error during discovery</DESC>
            </CONSTANT>

            <CONSTANT name="ERROR_INVALID_DISCOVERY_HOP_COUNT" value="ERROR_INVALID_DISCOVERY_HOP_COUNT" type="STRING">
                <DESC>Invalid multicast hop count</DESC>
            </CONSTANT>

            <CONSTANT name="ERROR_MALFORMED_PRINTER_STATUS_RESPONSE" value="ERROR_MALFORMED_PRINTER_STATUS_RESPONSE" type="STRING">
                <DESC>Malformed status response - unable to determine printer status</DESC>
            </CONSTANT>

            <CONSTANT name="ERROR_INVALID_FORMAT_NAME" value="ERROR_INVALID_FORMAT_NAME" type="STRING">
                <DESC>Invalid format name</DESC>
            </CONSTANT>

            <CONSTANT name="ERROR_BAD_FILE_DIRECTORY_ENTRY" value="ERROR_BAD_FILE_DIRECTORY_ENTRY" type="STRING">
                <DESC>Bad file directory entry</DESC>
            </CONSTANT>

            <CONSTANT name="ERROR_MALFORMED_FORMAT_FIELD_NUMBER" value="ERROR_MALFORMED_FORMAT_FIELD_NUMBER" type="STRING">
                <DESC>'^FN' integer must be between 1 and 999</DESC>
            </CONSTANT>

            <CONSTANT name="ERROR_INVALID_PRINTER_LANGUAGE" value="ERROR_INVALID_PRINTER_LANGUAGE" type="STRING">
                <DESC>Invalid printer language</DESC>
            </CONSTANT>

            <CONSTANT name="ERROR_INVALID_FILE_NAME" value="ERROR_INVALID_FILE_NAME" type="STRING">
                <DESC>Invalid file name</DESC>
            </CONSTANT>

            <CONSTANT name="ERROR_INVALID_PRINTER_DRIVE_LETTER" value="ERROR_INVALID_PRINTER_DRIVE_LETTER" type="STRING">
                <DESC>Invalid drive specified</DESC>
            </CONSTANT>
            
            <CONSTANT name="PRINTER_STATE_IS_HEAD_COLD" value="PRINTER_STATE_IS_HEAD_COLD" type="STRING">
                <DESC>use this name for requestState(), true if the head is cold</DESC>
            </CONSTANT>
            <CONSTANT name="PRINTER_STATE_IS_HEAD_OPEN" value="PRINTER_STATE_IS_HEAD_OPEN" type="STRING">
                <DESC>use this name for requestState(), true if the head is open</DESC>
            </CONSTANT>
            <CONSTANT name="PRINTER_STATE_IS_HEAD_TOO_HOT" value="PRINTER_STATE_IS_HEAD_TOO_HOT" type="STRING">
                <DESC>use this name for requestState(), true if the head is too hot</DESC>
            </CONSTANT>
            <CONSTANT name="PRINTER_STATE_IS_PARTIAL_FORMAT_IN_PROGRESS" value="PRINTER_STATE_IS_PARTIAL_FORMAT_IN_PROGRESS" type="STRING">
                <DESC>use this name for requestState(), true if there is a partial format in progress</DESC>
            </CONSTANT>
            <CONSTANT name="PRINTER_STATE_IS_PAUSED" value="PRINTER_STATE_IS_PAUSED" type="STRING">
                <DESC>use this name for requestState(), true if the printer is paused</DESC>
            </CONSTANT>
            <CONSTANT name="PRINTER_STATE_IS_RECEIVE_BUFFER_FULL" value="PRINTER_STATE_IS_RECEIVE_BUFFER_FULL" type="STRING">
                <DESC>use this name for requestState(), true if the receive buffer is full</DESC>
            </CONSTANT>
            <CONSTANT name="PRINTER_STATE_IS_RIBBON_OUT" value="PRINTER_STATE_IS_RIBBON_OUT" type="STRING">
                <DESC>use this name for requestState(), true if the ribbon is out</DESC>
            </CONSTANT>
            <CONSTANT name="PRINTER_STATE_LABEL_LENGTH_IN_DOTS" value="PRINTER_STATE_LABEL_LENGTH_IN_DOTS" type="STRING">
                <DESC>use this name for requestState(), The length of the label in dots</DESC>
            </CONSTANT>
            <CONSTANT name="PRINTER_STATE_LABELS_REMAINING_IN_BATCH" value="PRINTER_STATE_LABELS_REMAINING_IN_BATCH" type="STRING">
                <DESC>use this name for requestState(), The number of labels remaining in the batch</DESC>
            </CONSTANT>
            <CONSTANT name="PRINTER_STATE_NUMBER_OF_FORMATS_IN_RECEIVE_BUFFER" value="PRINTER_STATE_NUMBER_OF_FORMATS_IN_RECEIVE_BUFFER" type="STRING">
                <DESC>use this name for requestState(), The number of formats currently in the receive buffer of the printer</DESC>
            </CONSTANT>
            <CONSTANT name="PRINTER_STATE_PRINT_MODE" value="PRINTER_STATE_PRINT_MODE" type="STRING">
                <DESC>use this name for requestState(), The print mode</DESC>
            </CONSTANT>
        </CONSTANTS>
        
        <METHODS access="INSTANCE">            
            <METHOD name="retrieveFileNames" hasCallback="mandatory">
                <DESC>Retrieves the names of the files which are stored on the printer. Works asynchonously, use callback to check the result.</DESC>
                <CALLBACK type="HASH">
                    <PARAMS>
                        <PARAM name="status" type="STRING">
                            <DESC>PRINTER_STATUS_SUCCESS, PRINTER_STATUS_ERROR</DESC>
                        </PARAM>
                        <PARAM name="fileNames" type="ARRAY">
                            <PARAM type="STRING"></PARAM>
                            <DESC></DESC>
                        </PARAM>
                    </PARAMS>
                </CALLBACK>
                <PLATFORM>WM, Android, iOS</PLATFORM> 
            </METHOD>

            <METHOD name="retrieveFileNamesWithExtensions" hasCallback="mandatory">
                <DESC>This method only returns files which have the extensions in "extensions". Works asynchonously, use callback to check the result.</DESC>
                <PARAMS>
                    <PARAM name="extensions" type="ARRAY">
                        <PARAM type="STRING"></PARAM>
                        <DESC>The list of extensions that should be returned.</DESC>
                    </PARAM>
                </PARAMS>
                <CALLBACK type="HASH">
                    <PARAMS>
                        <PARAM name="status" type="STRING">
                            <DESC>PRINTER_STATUS_SUCCESS, PRINTER_STATUS_ERROR</DESC>
                        </PARAM>
                        <PARAM name="fileNames" type="ARRAY">
                            <PARAM type="STRING"></PARAM>
                            <DESC></DESC>
                        </PARAM>
                    </PARAMS>
                </CALLBACK>
                <PLATFORM>WM, Android, iOS</PLATFORM> 
            </METHOD>

            <METHOD name="sendFileContents" hasCallback="optional">
                <DESC>Sends the contents of a file to the printer. Equals to printing raw string with content of specified file. Should be used to print ZPL and CPCL commands stored inside predefined filed. Works asynchonously, use callback to check the result.</DESC>
                <PARAMS>
                    <PARAM name="path" type="STRING">
                        <DESC>Location of file to print.</DESC>
                    </PARAM>
                </PARAMS>
                <CALLBACK type="STRING">
                    <DESC>Returns result of a printing attempt. PRINTER_STATUS_SUCCESS, PRINTER_STATUS_ERROR</DESC>
                </CALLBACK>
                <PLATFORM>WM, Android, iOS</PLATFORM> 
            </METHOD>

            <METHOD name="printStoredFormatWithHash" hasCallback="optional">
                <DESC>Prints a stored format on the printer, filling in the fields specified by the Hash. Works asynchonously, use callback to check the result.</DESC>
                <PARAMS>
                    <PARAM name="formatPathOnPrinter" type="STRING">
                        <DESC>The location of the file on the printer (e.g. "E:FORMAT.ZPL").</DESC>
                    </PARAM>
                    <PARAM name="vars" type="HASH">
                        <DESC>An Hash which contains the key/value pairs for the stored format. For ZPL formats, the key number should correspond directly to the number of the field in the format. Number keys should be passed as String: '1':'field1' etc. CPCL format do not supported - only ZPL!</DESC>
                    </PARAM>
                </PARAMS>
                <CALLBACK type="STRING">
                    <DESC>Returns result of a printing attempt. PRINTER_STATUS_SUCCESS, PRINTER_STATUS_ERROR, </DESC>
                </CALLBACK>
                <PLATFORM>Android, iOS</PLATFORM> 
            </METHOD>

            <METHOD name="printStoredFormatWithArray" hasCallback="optional">
                <DESC>Prints a stored format on the printer, filling in the fields specified by the array. Works asynchonously, use callback to check the result.</DESC>
                <PARAMS>
                    <PARAM name="formatPathOnPrinter" type="STRING">
                        <DESC>The location of the file on the printer (e.g. "E:FORMAT.ZPL").</DESC>
                    </PARAM>
                    <PARAM name="vars" type="Array">
                        <DESC>An array of strings representing the data to fill into the format. For ZPL formats, index 0 of the array corresponds to field number 2 (^FN2). For CPCL, the variables are passed in the order that they are found in the format</DESC>
                    </PARAM>
                </PARAMS>
                <CALLBACK type="STRING">
                    <DESC>Returns result of a printing attempt. PRINTER_STATUS_SUCCESS, PRINTER_STATUS_ERROR, </DESC>
                </CALLBACK>
                <PLATFORM>WM, Android, iOS</PLATFORM> 
            </METHOD>

            <METHOD name="storeImage" hasCallback="optional">
                <DESC>Stores the specified image to the connected printer as a monochrome image. Works asynchonously, use callback to check the result. The image will be stored on the printer at printerDriveAndFileName with the extension GRF. If a drive letter is not supplied, E will be used as the default (e.g. FILE becomes E:FILE.GRF). If an extension is supplied, it is ignored (E:FILE.BMP becomes E:FILE.GRF). Note: if the image resolution is large (e.g. 1024x768) this method may take a long time to execute. There are device OS limitations on supported file formats and image sizes. iOS is supporting only JPG and PNG files. WM can fail to handle large (>1024x1024 pixel) images.  </DESC>
                <PARAMS>
                    <PARAM name="printerDriveAndFileName" type="STRING">
                        <DESC>Path on the printer where the image will be stored.</DESC>
                    </PARAM>
                    <PARAM name="imageFilePathOnDevice" type="STRING">
                        <DESC>Path to the file containing the bitmap image to send.</DESC>
                    </PARAM>
                    <PARAM name="width" type="INTEGER">
                        <DESC>Desired width of the printed image, in dots. Passing -1 will preserve original width.</DESC>
                    </PARAM>
                    <PARAM name="height" type="INTEGER">
                        <DESC>Desired height of the printed image, in dots. Passing -1 will preserve original height.</DESC>
                    </PARAM>
                </PARAMS>
                <CALLBACK type="STRING">
                    <DESC>Returns result of a printing attempt. PRINTER_STATUS_SUCCESS, PRINTER_STATUS_ERROR, </DESC>
                </CALLBACK>
                <PLATFORM>WM, Android, iOS</PLATFORM> 
            </METHOD>
        </METHODS>
        
        <USER_OVERVIEW>
        </USER_OVERVIEW>
        <VER_INTRODUCED>1.0.0</VER_INTRODUCED>
        <PLATFORM>
         </PLATFORM>
    </MODULE>
</API>    
