# Intent API Guide

The Intent API class allows your app to communicate with other apps on your device. With this API, you'll be able to communicate between your apps (created either with or without the Rhodes framework) and / or with native device apps to leverage the power of those apps.

**NOTE: To us this class, you should first read up on the [Intent API](../api/intent) in our API docs so that the concepts mentioned here are not so cryptic.**

## What are Intents?
Before we start sending or receiving intents, we first need to answer the question, "What are intents?". Intents are a mechanism setup and used by the Android operating system that the OS uses in order to interact with the various apps and services available on Android devices. since the API for this mechanism is exposed for public use, we can utilize this API to send and receive intents so that our apps can "talk" to other apps and / or services.

### Why Do I Want to Send or Receive Intents?
When we talk about "sending" or "receiving" an intent, we are referring to the action of sending an object to the OS that can be interpreted by the OS and turned into a native device command. For instance, if we send an intent with the "uri" of **"geo:37.422, -122.084"**, the Android OS knows to launch it's default maps app (since we did not specify an appName), and pinpoint Google's Mountain View headquarters. This is useful since we don't want to have to write our own mapping program that may not be as good as Google's provided mapping app.

You can also read up on intents on Google's [Android docs regarding intents](http://developer.android.com/guide/components/intents-filters.html).

## Constructing an Intent
As you may have gleaned from our [Intent API docs](../api/intent), before sending an intent, you must first decide on the type of intent and the fashion in which you want the intent to interact with the OS. Let's use a simple example, the one listed above regarding sending a GeoLocation coordinate to the maps app. You will need information from your OS provider's documentation on exactly what data to use here.

For our example, we will use Android and the information documented [here](http://developer.android.com/guide/components/intents-common.html#Maps). When the docs here reference a constant, we will need to use the actual string that it refers to since we are not using the native intent API, but our own cross-platform extraction of the Android Intent API. For example, when the Android docs show "ACTION_VIEW", we need to instead use "android.intent.action.VIEW", which can be retrieved by clicking on the constant name in the Android docs.

### Necessary Information
There are a few things we need to form an intent. The entire list of parameters is laid out in the Intent API doc so we will only talk about the ones that we'll need to use for this intent. 

The required parameters for a given intent are listed on Android's docs, for this we will need:

* Intent Action   - This determines what kind of action the intent is going to request from the OS.
* Intent Type     - This is the type of intent that we want to send to the OS (In most cases it will be START_ACTIVITY).
* Data URI Scheme - This is where we place the coordinates string for the geolocation pinpoint.

## Sending Intents
### Assemble the Parameters
Now that we know the different pieces we'll need, let's put the intent together. These are the parameters that we need to send to open the maps app and plot the location of Google's Mountain View HQ.

* action     => "android.intent.action.VIEW"
* intentType => Rho::Intent::START_ACTIVITY (RUBY)
* intentType => Rho.Intent.START_ACTIVITY (JS)
* uri        => "geo:37.422, -122.084"

### Send the Intent
Now that we have these, we simply need to put them into a hash and use the Rho [Intent API method](../api/intent#msend) `Intent.send()` to send the intent.

<ul class="nav nav-tabs">
    <li class="active"><a href="#ruby" data-toggle="tab">Ruby</a></li>
    <li><a href="#javascript" data-toggle="tab">JavaScript</a></li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade in active" id="ruby">
        <pre class='CodeRay'><code>:::ruby
def send_geo
  intentParams = {:action     => "android.intent.action.VIEW",
                  :intentType => Rho::Intent::START_ACTIVITY,
                  :uri        => "geo:37.422, -122.084"}

  Rho::Intent.send intentParams
end</code></pre>
    </div>
    <div class="tab-pane fade" id="javascript">
    <pre class='CodeRay'><code>:::javascript</code></pre>
    </div>
</div>

This intent will send the string "geo:37.422, -122.084" to the Android OS and request that it start the activity that handles geolocation coordinates. If there are multiple different apps on the device that provide geolocation services, an app chooser will pop up asking the user to choose which app they want to open the coordinates in.

## Receiving Intents
Ok, we can send intents, great! But what if what you want to do is send an intent to another one of your apps, or receive an intent from another app? We can also use the Rho Intent API for this but it requires a bit more work than the sending did.

There are three things we need to do to receive an intent:

* Add an intent receiver to the AndroidManifest.erb
* Add the code to start listening for incoming intents.
* Add a callback handler to handle the data coming in from an intent.

### Add an Intent Receiver to the AndroidManifest.erb
When an app is installed on an Android device, it's Android manifest gets registered with the OS so that the OS knows whether or not the app is going to accept incoming intents. We need to make sure that our app's Android manifest is formatted correctly to let our app receive intents. The AndroidManifest.erb is held in the root directory of your app's project.

This is what our intent-filter will look like to receive a simple, plain text, intent from another app:

`<app_root/AndroidManifest.erb>`
    :::xml
    <manifest>
      ...
      <receiver android:name='com.rhomobile.intents'>
        <intent-filter>
          <action android:name="android.intent.action.SEND"/>
          <category android:name="android.intent.category.DEFAULT"/>
          <data android:mimeType="text/plain"/>
        </intent-filter>
      </receiver> 
      ...
    </manifest>

Let's explain a few of the items here:

* receiver android:name - This is the name of our app as it will be registered with the Android OS.
* action android:name   - This is the intent action that our app will expect from intents the it receives.
* category android:name - This is the category of intents that our app will expect. A value of default will accept all categories
* data android:mimeType - This is the data type that our app will be expecting to handle in intents that it receives.

### Add Code to Start Listening for Intents
Now, before we can start sending intents to this app, we need to add some code that will allow us to tell the app to start listening for intents. We do this with the Rho [Intent API method](../api/intent#mstartListening) `Intent.startListening()`.

<ul class="nav nav-tabs">
    <li class="active"><a href="#ruby" data-toggle="tab">Ruby</a></li>
    <li><a href="#javascript" data-toggle="tab">JavaScript</a></li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade in active" id="ruby">
        <pre class='CodeRay'><code>:::ruby
def start_listening
  Rho::Intent.startListening "/app/Intent/listening_for_intent_callback"
end</code></pre>
    </div>
    <div class="tab-pane fade" id="javascript">
    <pre class='CodeRay'><code>:::javascript</code></pre>
    </div>
</div>

You can see here that we have specified a callback handler but we have not yet defined the callback handler, so let's do that now.

### Add a Callback Handler
We can now receive intents but, without a callback handler, receiving an intent is meaningless.

<ul class="nav nav-tabs">
    <li class="active"><a href="#ruby" data-toggle="tab">Ruby</a></li>
    <li><a href="#javascript" data-toggle="tab">JavaScript</a></li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade in active" id="ruby">
        <pre class='CodeRay'><code>:::ruby
def listening_for_intent_callback
  Rho::Notification.showPopup({:message => @params['uri'],
                               :title => "Alert!",
                               :buttons => ["ok"]})
end</code></pre>
    </div>
    <div class="tab-pane fade" id="javascript">
    <pre class='CodeRay'><code>:::javascript</code></pre>
    </div>
</div>

All we are doing with the received data is showing a pop-up with the data that is passed in through the `uri` parameter.

With these pieces complete, we should be able to compile an intent to send to this app and display the data that we send.

### Construct Intent to be Received
From whatever other app you want to send an intent to this app, you must construct an intent to send to it. Since we have already done this once, I'll forego the detailed explanation and get straight to the code.

<ul class="nav nav-tabs">
    <li class="active"><a href="#ruby" data-toggle="tab">Ruby</a></li>
    <li><a href="#javascript" data-toggle="tab">JavaScript</a></li>
    <li><a href="#android" data-toggle="tab">Android Java</a></li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade in active" id="ruby">
        <pre class='CodeRay'><code>:::ruby
def send_intent
  intentParams = {:action      => "android.intent.action.VIEW",
                  :intentType  => Rho::Intent::START_ACTIVITY,
                  :uri         => "Test String!",
                  :appName     => "com.rhomobile.intents",
                  :targetClass => "com.rhomobile.rhodes.RhodesActivity"}

  Rho::Intent.send intentParams
end</code></pre>
    </div>
    <div class="tab-pane fade" id="javascript">
    <pre class='CodeRay'><code>:::javascript</code></pre>
    </div>
    <div class="tab-pane fade" id="android">
    <pre class='CodeRay'><code>:::java</code></pre>
    </div>
</div>