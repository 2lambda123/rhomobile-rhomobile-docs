# Building a native extension

## Introduction

RhoMobile provides you with access to a wide variety of features offered by the device your application runs on, such as [sensors](../api/sensor) or [barcode scanners](../api/barcode). If you need to interact with the native platform in a way that the public RhoMobile APIs do not address, it is time to build a native extension.

**NOTE: Native extensions are used only when strictly necessary. If you need to add functionality to your application and a compatible Ruby gem or Javascript library is available, these are usually preferable.**

## Overview

The process of building a native extension involves
* using a code generator to build an XML descriptor that contains the structure of your new API
* updating the template to add the names and features of the methods your API will provide
* running the code generator to create stub implementations for the different platforms
* implementing your API on the platform(s) you intend to support in native code.
* adding the new extension to your build.yml so that it is available in your application


## Getting started - Basic extension walkthrough

**NOTE: This guide contains a walkthrough of creating the simplest possible extension, and then progressively adding more features to it. If you need to build an extension for your application and have not done so before, it is recommended that you do not skip ahead but instead read the whole guide in order, as each section builds on the steps and knowledge acquired in the sections that came earlier.**


We will begin by creating a sample "Greeting" extension. Our target is to have a new API available as `Rho::Greeting` (Ruby) or `Rho.Greeting` (Javascript) with the following methods:

* welcome(username)
* farewell(username)

These methods will be `static`, that is, they can be called directly on the Greeting class in the same way you can call methods on [Rho::Log](../api/Log)

Ruby:
	:::ruby
	greeting = Rho::Greeting.welcome("John Doe") # <= "Welcome, John Doe"
	farewell = Rho::Greeting.farewell("Jane Doe") # <= "Farewell, Jane Doe"

Javascript:
	:::javascript
	var greeting = Rho.Greeting.welcome("John Doe") // <= "Welcome, John Doe"
	var farewell = Rho.Greeting.farewell("Jane Doe") // <= "Farewell, Jane Doe"


From the console, change into your application's directory and run:

	:::console
	rhogen extension greeting

this will create the initial set of files for the new extension. Open the new `extensions/greeting` folder and you will find:

* ext.yml - you do not normally need to modify this file
* public/api/generated/Rho.Greeting.js - automatically generated javascript bindings
* ext/platform - one folder for each supported platform (android, iphone, wm, wp8)
* ext/shared/generated - automatically generated glue code
* ext/greeting.xml - API descriptor. This is where you define which methods your API provides, the parameters they expect and the result they return, as well as provide user documentation.

**NOTE: Whenever you see a directory named `generated`, keep in mind that everything it contains can be overwritten by the code generator on subsequent runs. Consider these directories as "read-only", do not modify any of these files because your changes will be lost.**

## Adding an extension to your application

Merely creating an extension does not automatically include it in an application: you still need to edit the `build.yml` file and add it:

	:::yaml
	extensions:
		- greeting

## Overview of the API descriptor (XML) file

The API descriptor (`extensions/<extension name>/ext/<extension name>.xml`) contains all the information required by the `rhogen` code generator to build a basic template that you can then implement for each platform. The default descriptor that is generated contains some sample methods that serve as documentation and starting point for your own. The structure of the API descriptor is as follows:

	:::xml
	<API> <!-- Root container for all elements -->
		<MODULE>
			<ALIASES></ALIASES> <!-- optional -->

			<HELP_OVERVIEW> <!-- documentation -->
			</HELP_OVERVIEW>

			<MORE_HELP> <!-- documentation -->
			</MORE_HELP>

			<TEMPLATES> <!-- include common features automatically in your API -->
			</TEMPLATES>

			<PROPERTIES> <!-- supported properties of this extension -->
				<PROPERTY>
				</PROPERTY>
			</PROPERTIES>

			<METHODS>	<!-- supported methods of this extension -->
				<METHOD>
				</METHOD>
			</METHODS>

			<USER_OVERVIEW> <!-- documentation -->
			</USER_OVERVIEW>

			<VER_INTRODUCED> <!-- documentation -->
			</VER_INTRODUCED>
		</MODULE>
	</API>

Sections marked "documentation" are meant to be user-readable, while `<MODULE>`, `<ALIASES>`, `<TEMPLATES>`, `<PROPERTIES>` and `<METHODS>` drive the code generation and implementation of the extension.

**NOTE: The set of attributes supported by each of these tags is fully documented in [Reference: the API descriptor in depth](#reference-the-api-descriptor-in-depth). The basic extension shown in this guide does not make use of every feature.**

The default descriptor already contains a set of methods and includes some templates. For simplicity, instead of using the default, we will start from the smallest possible descriptor and add features to our extension gradually. This will let you see how all the pieces fits together and what each change provides; once you start to build a real extension, you will know what you can save from the default and what has to be removed for your particular case.

Keep a mental note of the methods that the default descriptor includes (`getPlatformName`, `calcSumm`, `joinStrings`) and
replace the contents of your greeting.xml file with the following:

	:::xml
	<?xml version = "1.0"?>
	<?xml-stylesheet type="text/xsl" href="pb_help.xsl"?>
	<API>
	    <MODULE name="Greeting" parent="Rho">
	        <HELP_OVERVIEW>Example extension api</HELP_OVERVIEW>
	        <MORE_HELP>This is example of API. Implementation contain in extension.</MORE_HELP>
	    
	        <TEMPLATES>
	        </TEMPLATES>

	        <PROPERTIES>
	        </PROPERTIES>

	        <METHODS>
	        	<METHOD name="welcome" access="STATIC">
	        		<PARAMS>
	                    <PARAM name="user" type="STRING"></PARAM>
	                </PARAMS>

	                <RETURN type="STRING">
	                    <DESC>Warm welcome for the user</DESC>
	                </RETURN>
				</METHOD>	        			
	        </METHODS>
	        
	        <USER_OVERVIEW>
	        </USER_OVERVIEW>

	        <VER_INTRODUCED>1.0.0</VER_INTRODUCED>
	        <PLATFORM>
	        </PLATFORM>
	    </MODULE>
	</API>    


From the command line, switch to the `extensions/greeting/ext` folder and run

	:::console
	rhogen api greeting.xml

**NOTE: Every time you make changes to the API descriptor and regenerate files, run the appropriate rake clean task (i.e., `rake clean:android` or `rake clean:iphone`) before building your application, otherwise you may sometimes experience compilation errors.**

This command processes the descriptor and rebuilds the auto-generated files. You are now ready to start adding your implementation.

## High-level structure of extensions

The `rhogen` command builds a set of files for each platform, divided in two sets:

* Base classes and interfaces to use in your own implementation. These are regenerated automatically.
* Implementation classes. These contain your custom code. They must implement / extend the autogenerated base classes and are generated only the first time: when you make changes to the API descriptor and re-run the `rhogen` command, you will also need to make the appropriate changes to these files manually.


Depending on the platform you are working on, complete one of the following sections:

### Android

Android extensions place their generated base classes and interfaces in `<extension name>/ext/platform/android/generated` and your implementation in `<extension name>/ext/platform/android/src`

Open `extensions/greeting/ext/platform/android/generated/src/com/rho/greeting/IGreetingSingleton.java` and you will see it declares a very simple interface with a single method, `welcome`, that takes a `String` parameter called `user`, like you specified in the API descriptor.

However, instead of returning `String` like you would expect from the declaration, it is `void` and instead takes a second parameter called `result` of type `IMethodResult`. All methods in your extension will follow this pattern: they will be declared `void` and the `result` parameter is what allows you to return a value.

Now open `extensions/greeting/ext/platform/android/src/com/rho/greeting/GreetingSingleton.java`. This class is declared to implement the `IGreetingSingleton` interface we just saw in the previous step but it will not compile in its present form. This is an implementation class, which means it was autogenerated the first time but it is now up to you to make the relevant changes to implement the API correctly.

In order to do that:
* remove the call to `super(this)` in the constructor
* remove all existing methods
* add the missing method:

	:::java
    @Override 
    public void welcome(String user, IMethodResult result) {
    	result.set("Welcome, "+user);
    }

Remember that the API descriptor initially had some methods (`getPlatformName`, `calcSumm`, `joinStrings`) that are no longer present. For the extension to build cleanly, you must remove these methods from `android/src/com/rho/greeting/Greeting.java`


### iOS

iOS extensions place their generated base classes and interfaces in:
* `<extension name>/ext/platform/iphone/generated/base_impl`
* `<extension name>/ext/platform/iphone/generated/stub_impl`

Your code must be located in `<extension name>/ext/platform/iphone/impl`

Open `stub_impl/GreetingSingleton.h` and copy the `welcome` method to `impl/GreetingSingleton.h`, removing the other methods that are present. Do the same between `stub_impl/GreetingSingleton.m` and `impl/GreetingSingleton.m`, fleshing out the method like this:

	:::objective-c
	-(void) welcome:(NSString*)user methodResult:(id<IMethodResult>)methodResult {
		[methodResult setResult:[@"Welcome, " stringByAppendingString:user]];
	}

You will have noticed that, although the API descriptor declared that the `welcome` method takes a single parameter (`user`)and returns a `String`, the generated method takes two parameters (`user` and `methodResult`) and returns void. All extension methods will follow this pattern of being void and receiving an extra parameter of type `IMethodResult` to return a value.

However, instead of returning `String` like you would expect from the declaration, it is `void` and instead takes a second parameter called `result` of type `IMethodResult`. All methods in your extension will follow this pattern: they will be declared `void` and the `result` parameter is what allows you to return a value.

### Windows Mobile

The `rhogen` tool creates a Visual Studio solution project in `extensions/greeting/ext/platform/wm/Greeting.sln`. When you open it in VS 2008, you will see it contains `Greeting_impl.cpp", which is where implementation code is added for any methods declared in the API descriptor, and `shared/generated/cpp` which contains the base classes and interfaces that your implementation must extend. 

Open `shared/generated/cpp/IGreeting.h" and you will find that `IGreetingSingleton` declares the `welcome` method defined in the API descriptor, with some differences: it is `void` instead of returning a `String` and it has an extra parameter of type `rho::apiGenerator::CMethodResult&` called oResult. Extension methods will follow this pattern of being `void` and taking an extra CMethodResult parameter which lets you return a value to the caller.

In `Greeting_impl.cpp`, update class `CGreetingSingleton` to match the following:

	:::c++
	class CGreetingSingleton: public CGreetingSingletonBase
	{
	    ~CGreetingSingleton(){}

	public:
		void welcome( const rho::String& user, rho::apiGenerator::CMethodResult& oResult) {
			oResult.set("Welcome, "+user);
		}
	};

All you need to do is remove the methods called `getInitialDefaultID` and `enumerate` (these were generated automatically but they do not apply to our extension) and add an implementation of `welcome` with the signature found in `shared/generated/cpp/IGreeting.h`


### Windows Phone 8

TODO

## Invoking the new extension

Now that the native part of the extension is implemented, you can start to use it in your application. Open `app/index.erb` and edit the `content` div to match the following:

	:::html
	<div data-role="content">
		<%= Rho::Greeting.welcome("John doe") %>
	</div>

Make sure you [added the extension to build.yml](#Adding-an-extension-to-your-application) and run your application. You will see the extension in action, returning the value as you would expect, exactly like any other API call.

The build system creates all the initialization and glue code so that your extensions are available from both Ruby and Javascript code automatically. The following code will also work:

	:::javascript
	alert(Rho.Greeting.welcome("John doe"));


## A deeper look into the two approaches to developing extensions. Singleton and Factory

Now that you have a good overview of how to build a simple extension, you can expand your knowledge with more advanced concepts.

The basic extension you just developed followed the "singleton" pattern, which means you don't create instances of the `Greeting` class but instead just call methods on it. This is how `Rho.Log` works and is appropriate when it does not make sense to have more than one instance of a particular object.

Another approach is also supported, the "factory" pattern. This is how many other RhoMobile APIs work like [Barcode](../api/barcode) and [Camera](../api/Camera) are implemented: there may be more than one barcode scanner or camera present in a device, so you can enumerate them and get a different instance representing each of them.

Which pattern you use depends on what exactly your extension needs to achieve and is a decision that must be taken early.

In order to create a `Factory`-style extension, you will typically:

* Keep `<DEFAULT_INSTANCE/>` inside the `<TEMPLATES>` section of the API descriptor
* Keep the `enumerate` method
* Implement a set of `instance` methods and add the same methods as `static` also, with the implementation delegating to a default instance.

The starter API descriptor builds Factory-style extensions by default. Now that you know what each piece of the puzzle means, you are ready to understand how the generated implementation works and use it as a base for your own extension.

## Using callbacks

There are many methods in the RhoMobile standard APIs that, instead of returning a value immediately, receive a callback parameter and invoke it when the value is available. For example, [Barcode.take](../api/barcode#mtake) receives a `hash` of properties to configure the scanner and a `callback` that will be executed when the scanner reads a barcode or times out.

The `<METHOD>` tag in the API descriptor accepts a `hasCallback` attribute with one of the following values: `none`, `optional`, `mandatory`.

* `hasCallback="none"` (the default): the method will return a result value synchronously
* `hasCallback="mandatory"` : the method will never return a value and will always invoke its callback
* `hasCallback="optional"` : if a callback is present, it will be used, otherwise, the method will return its result synchronously

## Returning values

The implementations of all native methods in an extension follow the same pattern:

- they are declared as `void`
- their last parameter is a special `MethodResult` object, used as a conduit to return values

If your return value is a primitive or simple type (number, string), you can call `methodResult.set` directly as in the examples above. If you need to return a composite object such as a `hash` or an `array`, there are some special type mappings to take into account.

<table class="re-table" style="width: 100%">
	<thead>
		<tr>
			<th>
				In order to return
			</th>
			<th>
				On
			</th>
			<th>
				Use
			</th>
			<th>
				Example
			</th>
		</tr>
	</thead>
	<tbody>
		<tr class="clsOddRow">
			<td>Primitive types, strings
			</td>
			<td>All platforms
			</td>
			<td>the raw value
			</td>
			<td>
				<br/>				
				Java:
				<br/>
				<code>methodResult.set(42);</code>
				<br/>
				<code>methodResult.set("Welcome");</code>
				<br/>
				<br/>
				Objective-C:
				<br/>
				<code>[methodResult setResult:42];</code>
				<br/>
				<code>[methodResult setResult:@"Welcome"];</code>
				<br/>
				<br/>
				C++:
				<br/>
				<code>oResult.set(42);</code>
				<br/>
				<code>oResult.set("Welcome");</code>
				<br/>
				<br/>
				C#: TODO
			</td>
		</tr>

		<tr class="clsEvenRow">
			<td>Array
			</td>
			<td>Android
			</td>
			<td>
				<code>java.util.List</code>
			</td>
			<td>
				<br/>
				<code>
				List myList = new LinkedList();<br>
				myList.add(42);<br>
				myList.add(7);<br>
				methodResult.set(myList);<br>
				</code>
			</td>
		</tr>

		<tr class="clsOddRow">
			<td>Array
			</td>
			<td>iOS
			</td>
			<td><code>NSArray</code>
			</td>
			<td>
				<br/>
				<code>
				NSArray* array = [NSArray arrayWithObjects:<br/>
					@"String1",<br/>
					@"String2",<br/>
					nil];<br/>
				[methodResult setResult:array];<br/>
				</code>
			</td>
		</tr>

		<tr class="clsEvenRow">
			<td>Hash
			</td>
			<td>Android
			</td>
			<td><code>java.util.Map<String,Object></code>
			</td>
			<td>
				<br/>
				<code>
					Map<String,Object> map = new java.util.HashMap<String,Object>();<br/>
					map.put("key1", "value1");<br/>
					map.put("key2", "value2");<br/>
					methodResult.set(map);<br/>
				</code>
			</td>
		</tr>

		<tr class="clsOddRow">
			<td>Hash
			</td>
			<td>iOS
			</td>
			<td>NSDictionary
			</td>
			<td>
				<br/>
				<code>
					NSDictionary* dict = [NSDictionary dictionaryWithObjectsAndKeys:<br/>
					@"value1", @"key1", @"value2", @"key2", nil];<br/>
					methodResult.set(dict);<br/>
				</code>
			</td>
		</tr>

<!--
		<tr class="clsOddRow">
			<td>
			</td>
			<td>
			</td>
			<td>
			</td>
			<td>
			</td>
		</tr>

		<tr class="clsEvenRow">
			<td>
			</td>
			<td>
			</td>
			<td>
			</td>
			<td>
			</td>
		</tr>
-->
	</tbody>
</table>




## Reference: The API descriptor in depth

### MODULE

The `<MODULE>` tag describes the API class you are building

Attributes:
* `name`. Mandatory. Contains the name of the generated API
* `parent`. Optional. If present, the generated API will created inside the specified namespace.
* `generateUnderscoreRubyNames`. Optional, default is `false`. If true, ruby method names will be created with underscores between words instead of camel case
* `generateAPI`. Optional, default is `true`. TODO
* `generateDoc`. Optional, default is `true`. If false, the module is considered to be internal and will not be documented. TODO: check how this affects user-built extensions outside of the core of RhoMobile

Examples:

	:::xml
	<MODULE name="Greeting" parent="Rho">

	<!-- You are not limited to using "Rho" as the parent -->
	<MODULE name="VisualFX" parent="MyCompany">

	<!-- parent can be multi-level -->
	<MODULE name="VisualFX" parent="MyCompany.Graphics">


### ALIAS

The `<ALIAS>` tag registers alternative names for a module, property or method

Examples:

	:::xml
	<METHOD name="getProperty">
			<ALIAS new="get_property"/>
	</METHOD>


### TEMPLATES

Templates add default behavior to modules, based on the templates present [here](https://github.com/rhomobile/rhodes/tree/master/res/generators/templates/api/xml_templates).


#### DEFAULT_INSTANCE

The `DEFAULT_INSTANCE` template is appropriate for factory-style modules. It provides static methods that delegate to a default instance. For example, the [Camera API](../api/camera) lets you enumerate cameras and use one in particular to take an image but you can also call static methods directly on the `Camera` class and it will use the default camera on the device. This template provides an implementation of

* `getDefault`
* `setDefault`

	:::xml
	<TEMPLATES>
		<DEFAULT_INSTANCE/>
	</TEMPLATES>

#### PROPERTY_BAG

The `PROPERTY_BAG` template allows your module to get and set its properties in a generic way in addition to specific property getters and setters. It provides:

* `getProperty(name)` - get the value of a single property
* `getProperties(names)` - return a hash with the values of an array of properties
* `setProperty(name,value)` - set a single property
* `setProperties(hash)` - set multiple properties in a single call

	:::xml
	<TEMPLATES>
		<PROPERTY_BAG/>
	</TEMPLATES>

### CONSTANTS

Container for `<CONSTANT>` elements

#### CONSTANT

Defines a Ruby and Javascript constant in a module

	:::xml
	<CONSTANT name="SUNDAY" value="Sun" type="STRING"/>
	<CONSTANT name="MONDAY" value="Mon" type="STRING"/>
	<CONSTANT name="DAYS_PER_WEEK" value="2" type="INTEGER"/>


### PROPERTIES

TODO

### PROPERTY

TODO

### VALUE

TODO

### METHODS

TODO

#### METHOD

TODO

#### PARAMS

TODO

##### PARAM

TODO

#### RETURN

TODO

#### CALLBACK

TODO
