Memcached
=========

Memcached is a key technology in scaling any web app beyond a certain size.  Used in combination with the Varnish HTTP cache, you can build extremely high-traffic sites, even with a relatively slow interpreted language like Ruby.

Heroku apps have access to a [memcached cluster](http://heroku.com/how/architecture#memory-cache), via the automatically created MemCache.cache singleton memcache client object.  You can use this in several ways: caching page or page fragments from Rails; caching ActiveRecord models to reduce load on the database; or to cache any arbitrary data from any kind of Rack app.

Rails page caching
------------------

The highest-performance technique for caching an entire public page is using a Cache-control header, as described in the section on [HTTP caching](/http-caching).  This will cause the page to be served from Varnish and never even hit your dyno, and should be used wherever possible.

If your page is private, then cache headers won't work, since you need to validate each user by cookie.  In this case, Rails' built-in page and fragment caching is a good in-betweeen solution (not as fast as HTTP page caching, but still much faster than rerendering on every pageview).

To configure ActionController to use Memcache as your cache store, add this to your config/environments/production.rb:

    ActionController::Base.cache_store = ActiveSupport::Cache::MemCacheStore.new(MemCache.config)

When should you use page caching (caches_action in the controller) vs. fragment caching (cache blocks inside the Erb template)?

If your site is private, but a particular page looks the same for all users who login, then use caches_action.  For example, the dashboard of an internal admin site might have a controller like this:

    class AdminController < ApplicationController
      before_filter :authenticate_user
      caches_action :index

This would cause the authenticate_user to be executed for each pageview, but the complete cotents of the page are cached and no rendering need be done after the first pass.

If you have parts of your page that are customized to each user (such as a header showing the username), but other parts which are the same for everyone, place your cacheable HTML into a cache do .. end block.  For example:

    <h1>Hello, <%= user %></h1>

    <% cache do %>
      Most popular posts this week:
      <%= render :partial => 'top_posts' %>
    <% end %>

Further reading: [Rails Envy Caching Tutorial](http://www.railsenvy.com/2007/3/20/ruby-on-rails-caching-tutorial-part-2)

ActiveRecord model caching
--------------------------

If you feel that you need to rerender the entire page on each pageview, but your model data is often the same, you can reduce the load on your database by caching the models.  One way to do this from Rails is the cached_model plugin.

Install the gem in your app.  You can use Rails gem dependencies and vendor the gem, or add it to your <a href="/gems">gems manifest</a>.  Then configure it, perhaps in config/initializers/production.rb:

    require 'cached_model'
    CACHE = MemCache.cache

To use, inherit your model from CachedModel instead of ActiveRecord::Base:

    class Post < CachedModel

Further reading: [Cached Model on Github](http://github.com/seattlerb/cached_model/tree/master)

Caching arbitrary data
----------------------

You can cache arbitrary data from Rails or any Rack app via a memcache client object that is created automatically.  The singleton object is accessible via MemCache.cache.  Set a value:

    MemCache.cache['mykey'] = 'myvalue'

Then later, in the same request - or more likely, a different one:

    MemCache.cache['mykey']        # => 'myvalue'

Further reading: [MemCache client gem on Github](http://seattlerb.rubyforge.org/memcache-client/)

