Connecting Directly to Web Services with Rhodes
===
Rhodes provides another utility for connecting to backend services besides the [`SyncEngine`](/rhodes/synchronization) called `AsyncHttp`.  Your application can use the `AsyncHttp` library to interact with web services, pull remote images, etc.

## AsyncHttp API
Below is the list of available `AsyncHttp` methods you can use to asyncrhonously make calls to http(s) services:

### Common Parameters
* `:url` - URL of the request.
* `:headers` - Hash of headers to send with the request.
* `:callback` - Callback action to execute when the request is done.
* `:callback_params` - (optional) Parameters to send to the callback.
* `:authentication` - (optional) Send Basic Auth header with request.  This takes the form:
		
		:::ruby
		:authentication => {
		  :type => :basic, 
		  :username => "john", 
		  :password => "secret"
		} 
		
* `:ssl_verify_peer` - (optional) Verify SSL certificates, `true` by default.

### `get(:url, :headers, :callback, :callback_params)`
Perform HTTP GET request to the specified `:url`.  You can also provide an optional hash of `:headers` and `:callback_params`.

	:::ruby
	Rho::AsyncHttp.get(
      :url => "http://www.example.com",
      :headers => {"Cookie" => cookie},
      :callback => (url_for :action => :httpget_callback)
    )

Example using Basic Auth:

	:::ruby
	Rho::AsyncHttp.get(
	  :url => "http://www.example.com",
	  :headers => {"Cookie" => cookie},
	  :callback => (url_for :action => :httpget_callback),
	  :authentication => {
	    :type => :basic, 
		:username => "john", 
		:password => "secret"
      }
	)
	
### `post(:url, :headers, :body, :callback, :callback_params)`
Perform HTTP POST request to the specified `:url`.  As with `get`, you can specify optional arguments:

	:::ruby
	# :post				HTTP POST body to send with request.
	# :http_command 	(optional) Use different HTTP method
	#					(i.e. "put").
	Rho::AsyncHttp.post(
	  :url => "https://www.example.com",
	  :headers => {"Cookie" => cookie},
	  :body => "username=john&password=secret",
	  :callback => url_for(:action => :httppost_callback),
	  :callback_param => "post=complete" 
	)
	
### `download_file(:url, :headers, :filename, :callback, :callback_params)`
Download a file to the specified filename.

	:::ruby
	file_name = File.join(Rho::RhoApplication::get_base_app_path, "test.jpg")
	
	# :filename		Full path to download file target.
	Rho::AsyncHttp.download_file(
	  :url => "http://www.google.com/images/logos/ps_logo2.png",
	  :filename => file_name,
	  :headers => {},
	  :callback => url_for(:action => :httpdownload_callback),
	)
	
### `upload_file(:url, :headers, :filename, :body, :callback, :callback_params)`
Upload the specified file using HTTP POST:

	:::ruby	
  	file_name = File.join(Rho::RhoApplication::get_base_app_path, "myfile.txt")

	# :filename		Full path to download file target.
	# :post			HTTP POST body to send with request.		
    Rho::AsyncHttp.upload_file(
      :url => "http://example.com/receive_file",
      :filename => file_name,
      :body => "" #=> leave blank, AsyncHttp will fill in multipart body
      :headers => {"Content-Type"=>"text/plain"}, #=> used as body text content type
      :callback => url_for(:action => :httpupload_callback),
      :callback_param => "" )

You can also send multiple files in a single `upload_file` request:

	:::ruby
	# :multipart				 Array of hashes containing
	#							 file information. 
	#
	# :multipart[:filename]		 Name of file to be uploaded.
	#
	# :multipart[:filename_base] (optional) Base directory containing
	#							 the :filename.
	# :multipart[:name]			 (optional) File type, defaults 
	#							 to "blob".
	#
	# :multipart[:content_type]	 (optional) Content-Type header, 
	#							 defaults to "application/octet-stream".
   	Rho::AsyncHttp.upload_file(
      :url => "some_url",
      :multipart => [
        { 
          :filename => file_name,
		  # if missed base name from file path used
          :filename_base => "files_to_upload",
          :name => "image",
          :content_type => "application/octet-stream"
        },
		# You can specify file content inline.
        {
          :body => "upload test",
          :name => "upload_body_test",
          :content_type => "plain/text"
        }
      ]
    )

### `cancel(cancel_callback = "*")` 
Cancel the current `AsyncHttp` call.  Defaults to "*", which cancels all requests.

	:::ruby
	AsyncHttp.cancel

## AsyncHttp Callback
As you noticed with each of the code samples above, we specified a `:callback` action.  This will execute with the `AsyncHttp` request is completed.  

### Callback Parameters
The following parameters are available in an `AsyncHttp` callback:

* `@params["body"]` - The body of the HTTP response.

**NOTE: In the case of a JSON request (Content-Type="application/json"), the `@params["body"] will be parsed automatically and contain a ruby data structure.  Otherwise, `@params["body"]` contains the raw response body.**

* `@params["headers"]` - A hash containing the response headers.
* `@params["cookies"]` - A the server cookies parsed and usable for subsequent requests.
* `@params["http_error"]` - HTTP error code if response code was not 200.


"""NOTE:""" to parse xml (application/xml) use rexml ruby extension : [[RhodesExtensions#Rexml|here]] <br/>
See rhodes-system-api-samples\AsyncHttp as an example

"""NOTE:""" to make synchronous call, just skip callback parameter(since 1.5.1):
<source lang="ruby">
    res = Rho::AsyncHttp.get( :url => "http://www.apache.org/licenses/LICENSE-2.0")
    puts "Sync http call: #{res}"
    @@get_result = res["body"]
</source>

==== With animated transitions ====
 
Making an async http request with animated transition enabled is not much different from making a request without transitions enabled. The main difference is the controller method must set a Wait-Page response header after making the async call. The response header tells the user interface that an async request has been spawned and that the returned view should be treated as an interstitial page.

The example below renders a waiting screen while awaiting a response from the async request. A view marked as Wait-Page is not considered part of the navigation history by the user interface and a back transition won"t navigate to this page.

<source lang="ruby">
  def async_show
    Rho::AsyncHttp.get(
            :url =>  "http://rhostore.heroku.com/products/#{@params["product_id"]}.json",
            :callback => (url_for :action => :show_callback),
            :callback_param => "")

    @response["headers"]["Wait-Page"] = "true"
    render :action => :waiting
  end
</source>

The async http callback can render the response by calling render_transition. This function is defined in ApplicationHelper so make sure you include it in your controller. Render transition works very much like render except that it will animate a transition from the previous page.

Below, a product model is created using the response from the web service and then calling render_transition, which leverages the show view template.

<source lang="ruby">
  include ApplicationHelper

  def show_callback
    if @params["status"] == "ok"
      @product = Product.new(@params["body"]["product"])
      @product.object = @product.id
      render_transition :action => :show
    else
      # In this example, an error just navigates back to the index w/o transition.
      WebView.navigate url_for :action => :index
    end
  end
</source>

==== With and without animated transitions ====

If you deploy to platforms that don"t handle animation (like Windows Mobile and BlackBerry) the controller will need to handle both cases. In your async request, you"ll need to set the callback_param with the @request value. There"s a helper function called """caller_request_hash_to_query""" defined in ApplicationHelper that you can invoke. The returned value is a string that looks like "_request=<json_request>", where json_request is an URL encoded JSON representation of the @request value. This parameter is used to give the callback function some context of whether the user interface made the request with or without transition enabled.

<source lang="ruby">
  include ApplicationHelper
  def async_show
    Rho::AsyncHttp.get(
            :url =>  "http://rhostore.heroku.com/products/#{@params["product_id"]}.json",
            :callback => (url_for :action => :show_callback),
            :callback_param => caller_request_hash_to_query)

    @response["headers"]["Wait-Page"] = "true"
    render :action => :waiting
  end
</source>

In your callback function, the first thing you need to do is invoke """caller_request_query_to_hash""" (also defined in ApplicationHelper) that basically deserializes the _request query parameter value passed in via callback_param shown in the example above. The function sets a @caller_request in the current context. You can then use it to determine if the user interface had transition enabled by inspecting the ""Transition-Enabled"" request header. For transitions, call render_transition, otherwise call WebView.navigate.

<source lang="ruby">
  def show_callback
    caller_request_query_to_hash

    if @params["status"] == "ok"
      @product = Product.new(@params["body"]["product"])
      @product.object = @product.id
      if @caller_request["headers"]["Transition-Enabled"] == "true"
        render_transition :action => :show
      else
        WebView.navigate url_for :action => :show, :id => @product.object
      end
    else
      WebView.navigate url_for :action => :index
    end
  end
</source>

=== Sample of Connecting Directly to a Backend Web Service ===

Here is a controller in the [http://github.com/rhomobile/system-api-samples Rexml sample in System API Samples]. It makes as AsyncHttp.get call to the test web service. It then parses the return with Rexml.  

<source lang="ruby">
   def webservicetest
    Rho::AsyncHttp.get(
      :url => "http://rhostore.heroku.com/products.xml",
      :callback => (url_for :action => :httpget_callback),
      :callback_param => "" )
      
    render :action => :wait
  end

  def get_res
    @@get_result    
  end

  def get_error
    @@error_params
  end
  
  def httpget_callback
    puts "httpget_callback: #{@params}"

    if @params["status"] != "ok"
        @@error_params = @params
        WebView.navigate ( url_for :action => :show_error )        
    else
        @@get_result = @params["body"]
        puts "@@get_result : #{@@get_result}"

        begin
            require "rexml/document"
        
            doc = REXML::Document.new(@@get_result)
            puts "doc : #{doc}"
        rescue Exception => e
            puts "Error: #{e}"
            @@get_result = "Error: #{e}"
        end
            
        WebView.navigate ( url_for :action => :show_result )
    end

  end

  def show_result
    render :action => :webservicetest, :back => "/app/RexmlTest"
  end
</source>