
#Rfid Module

<b>
The Rfid Module Provides access to control the functionality of the device's RFID reader.Currently the plugin is supported on MC 3190Z and MC 9190Z devices.
</b>

##Syntax

<table class="re-table"><tr><th class="tableHeading">rfid (Module) &lt;META&gt; Syntax
</th></tr><tr><td class="clsSyntaxCells clsOddRow"><p>&lt;META HTTP-Equiv="rfid" content="[parameter / method]"&gt;</p></td></tr><tr><td class="clsSyntaxCells clsEvenRow"><p>&lt;META HTTP-Equiv="rfid" content="tagEvent:url('[jsFunction | url]')"&gt;</p></td></tr></table>
<table class="re-table"><tr><th class="tableHeading">Rfid JavaScript Object Syntax:</th></tr><tr><td class="clsSyntaxCells clsOddRow">
By default the JavaScript Object <b>'rfid'</b> will exist on the current page and can be used to interact directly with the rfid.
</td></tr><tr><td class="clsSyntaxCells clsEvenRow">
To Invoke rfid methods via JavaScript use the following syntax: rfid.method();
<P />e.g. <b>rfid</b>.enumerate();
</td></tr><tr><td class="clsSyntaxCells clsOddRow">
To Set rfid parameters via JavaScript use the following syntax: rfid.parameter = 'value'; remembering to enclose your value in quotes where appropriate.  
<P />e.g. <b>rfid</b>.antennaSelected = 'value';
</td></tr><tr><td class="clsSyntaxCells clsEvenRow">						
To Set rfid return events via JavaScript use the following syntax: rfid.event = Javascript Function;
<P />e.g. <b>rfid</b>.enumRFIDEvent = 'doFunction(%json)';
<P />
For more details on the event syntax and parameters see the <a href="RetrievalEvents">Retrieval Events</a> page.
</td></tr><tr><td class="clsSyntaxCells clsOddRow">							
To set multiple <a href="/rhoelements/EMMLOverview">EMML</a> parameters / events on a single line use the following syntax: rfid.setEMML("[Your EMML Tags]");
<P />
e.g. <b>rfid</b>.setEMML("antennaSelected:<i>value</i>;enumRFIDEvent:url('JavaScript:doFunction(%json)');enumerate");							
</td></tr></table>

<table class="re-table"><tr><th class="tableHeading">Rfid Ruby Object Syntax:</th></tr><tr><td class="clsSyntaxCells clsOddRow">
By default the Ruby Object <b>'Rfid'</b> will exist on the current page and can be used to interact directly with the Rfid. All Methods, Parameters and Events are the same as Javascript, however, notice <b>'Rfid'</b> needs to start with an uppercase letter. Another difference in Ruby is that methods do not end in <b>'()'</b></td></tr><tr><td class="clsSyntaxCells clsEvenRow">
To Invoke Rfid methods via Ruby use the following syntax: Rfid.method()
<P />e.g. <b>Rfid</b>.enumerate</td></tr><tr><td class="clsSyntaxCells clsOddRow">
To Set Rfid parameters via Ruby use the following syntax: Rfid.parameter = 'value' remembering to enclose your value in quotes where appropriate.  
<P />e.g. <b>Rfid</b>.antennaSelected = 'value'
</td></tr><tr><td class="clsSyntaxCells clsEvenRow">						
To Set Rfid return events via Ruby use the following syntax: Rfid.event = url_for(:action =&gt; :event_callback) 
<P />e.g. <b>Rfid</b>.enumRFIDEvent = url_for(:action =&gt; :rfid_event_callback)
<P />
For more details on the event syntax and parameters see the <a href="RetrievalEvents">Retrieval Events</a> page.
</td></tr><tr><td class="clsSyntaxCells clsOddRow" /></tr></table>


	

##Methods


Items listed in this section indicate methods or, in some cases, indicate parameters which will be retrieved.

<table class="re-table"><col width="10%" /><col width="68%" /><col width="22%" /><tr><th class="tableHeading">Name</th><th class="tableHeading">Description</th><th class="tableHeading">Default Value</th></tr><tr><td class="clsSyntaxCells clsOddRow"><b>enumerate</b></td><td class="clsSyntaxCells clsOddRow">Returns a list of RFID readers present on the device, and their respective capabilities via enumRFIDEvent.For the supported devices,this method will return the number of RFID readers in the device as 1.</td><td class="clsSyntaxCells clsOddRow" /></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>connect</b></td><td class="clsSyntaxCells clsEvenRow">Creates connection to the default RFID reader.By default,the plugin attempts to connect to the RFID Reader whenever the plugin is loaded.</td><td class="clsSyntaxCells clsEvenRow" /></tr><tr><td class="clsSyntaxCells clsOddRow"><b>disconnect</b></td><td class="clsSyntaxCells clsOddRow">Disconnects the current RFID connection and flushes all properties of the "rfid" module,except for the events.</td><td class="clsSyntaxCells clsOddRow" /></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>stop</b></td><td class="clsSyntaxCells clsEvenRow">Soft trigger to stop a runnning inventory or locateTag operation</td><td class="clsSyntaxCells clsEvenRow" /></tr><tr><td class="clsSyntaxCells clsOddRow"><b>performInventory</b></td><td class="clsSyntaxCells clsOddRow">Performs an inventory operation on the RFID reader which is started and stopped according to the trigger settings done by the application.
				By default, performInventory starts an inventory operation immediately and there is no default stop trigger.So, an explicit "stop" call must be made
				to stop the running Inventory in the default case.Any pre filters that have been added will be applied for the inventory operation.
				Tags will be reported as part of the TagData Array in the tagEvent's JSON object. When the property "invMemBank" is set(to either Reserved/EPC/TID/User) prior to calling performInventory,
				the corresponding memory-bank's data shall also be read for the tags being inventoried. For the inventoried tags, additional fields may be reported as part
				of tagEvent JSON by setting to true properties such as "enableTagCRC", "enableTagPC", "enableTagSeenCount", "enableTagRSSI", "enableTagAntennaID",etc.
				As long as inventory operation is running, the plugin cannot process those Meta-tags that could initiate a RFID operation like performInventory, locateTag, readTag and other Access operations.
				The plugin returns an error string describing that it is busy and it can perform other RFID operations only when the inventory is stopped.
				
				</td><td class="clsSyntaxCells clsOddRow" /></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>locateTag</b></td><td class="clsSyntaxCells clsEvenRow">Configures the locateTag operation which will look for a specific Tag ID on a specific antennaID, and will keep reporting tagEvents if the tag is found along with relative distance (In a scale of 0-100.100 being the closest) to help locate the requested tag.
				Also if the beepOnRead is enabled(Default state), the beep frequency varies proportionate to the relative distance(Geiger counter).The tagLocationing algorithms can use only one antenna to locate a tagID. Thus, antennaSelected cannot take the take default value 0, but one of the antenna IDs supported by the device.
				As with performInventory,the start and stop trigger settings can autonomously invoke and stop the locateTag operation.Please note that
				while the properties "reportUniqueTags","reportTrigger" are not relevant here,the tag field settings "enableTagAntennaID","enableTagRssi",etc are still applicable</td><td class="clsSyntaxCells clsEvenRow" /></tr><tr><td class="clsSyntaxCells clsOddRow"><b>killTag</b></td><td class="clsSyntaxCells clsOddRow">Kills the currently selected tag referenced by tagID, or kills tags that match the filter criteria.Requires tagKillPassword.
				tagID property is ignored if useAccessFilter property is set to true.If useAccessFilter is set to true, then  tagPatternA, tagPatternB and matchPattern will be used to filter out tags to perform the operation. 
				If tagID is empty and useAccessFilter is false(i.e the default value),the kill operation will be attempted on all the tags in the field of view.
				</td><td class="clsSyntaxCells clsOddRow" /></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>getRadioPowerState</b></td><td class="clsSyntaxCells clsEvenRow">Returns a boolean value (1 or 0)representing the radio power state via radioPowerStateEvent.</td><td class="clsSyntaxCells clsEvenRow" /></tr><tr><td class="clsSyntaxCells clsOddRow"><b>addPreFilter</b></td><td class="clsSyntaxCells clsOddRow">Adds a preconfigured filter to the currently selected antenna. It is used to sort out the subset of tags to participate in the next RFID operations.
				Multiple preFilters may be added,limited by the RFID reader. Each of them should be referenced by a unique value (which should be assigned to preFilterID property) before calling addPreFilter method.</td><td class="clsSyntaxCells clsOddRow" /></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>deletePreFilter</b></td><td class="clsSyntaxCells clsEvenRow">Deletes a pre-filter of the index set by preFilterID property.</td><td class="clsSyntaxCells clsEvenRow" /></tr><tr><td class="clsSyntaxCells clsOddRow"><b>clearPreFilters</b></td><td class="clsSyntaxCells clsOddRow">Deletes ALL preFilters</td><td class="clsSyntaxCells clsOddRow" /></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>radioPowerStateOn</b></td><td class="clsSyntaxCells clsEvenRow">Sets the radio power of the RFID module on</td><td class="clsSyntaxCells clsEvenRow" /></tr><tr><td class="clsSyntaxCells clsOddRow"><b>radioPowerStateOff</b></td><td class="clsSyntaxCells clsOddRow">Sets the radio power of the RFID module off</td><td class="clsSyntaxCells clsOddRow" /></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>tagRead</b></td><td class="clsSyntaxCells clsEvenRow">Reads from a tag or  a set of tags (defined by Access filter) using the preconfigured read Parameters.The tag data is returned via a tagEvent.The read data is available in tagData.memoryBankData field of the JSON object passed to tagEvent handler.
				tagID property is ignored if useAccessFilter property is set to true.If useAccessFilter is set to true, then  tagPatternA, tagPatternB and matchPattern will be used to filter out tags to perform the operation.If the tagID is empty and useAccessFilter is false, the read operation will be performed on all the tags in field of view.
				</td><td class="clsSyntaxCells clsEvenRow" /></tr><tr><td class="clsSyntaxCells clsOddRow"><b>tagWrite</b></td><td class="clsSyntaxCells clsOddRow">Writes data to a tag or a set of tags(defined by Access filter) using the preconfigured Write parameters.
				tagID property is ignored if useAccessFilter property is set to true.If useAccessFilter is set to true, then  tagPatternA, tagPatternB and matchPattern will be used to filter out tags to perform the operation. 
				If the tagID is empty and useAccessFilter is false, the write operation will be attempted on all the tags in field of view</td><td class="clsSyntaxCells clsOddRow" /></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>setTagID</b></td><td class="clsSyntaxCells clsEvenRow">Writes a preconfigured new tag ID to the currently selected tag.</td><td class="clsSyntaxCells clsEvenRow" /></tr><tr><td class="clsSyntaxCells clsOddRow"><b>setTagAccessPassword</b></td><td class="clsSyntaxCells clsOddRow">Writes a preconfgured new tag access password to the currently selected tag.</td><td class="clsSyntaxCells clsOddRow" /></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>setTagKillPassword</b></td><td class="clsSyntaxCells clsEvenRow">Writes a preconfigured new kill password to the currently selected tag.</td><td class="clsSyntaxCells clsEvenRow" /></tr><tr><td class="clsSyntaxCells clsOddRow"><b>setSingulation</b></td><td class="clsSyntaxCells clsOddRow">sets the preconfigured singulation parameters on the specified antenna.Atleast one of Session or TagPopulation parameters must be properly set before calling this method.</td><td class="clsSyntaxCells clsOddRow" /></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>getSingulation</b></td><td class="clsSyntaxCells clsEvenRow">Requests the current singulation parameters (session and tag population) for the given antenna.
				The result is returned in a singulationEvent.The property antennaSelected cannot take default value(0) because the singulation settings are returned only for one antennaID.
				</td><td class="clsSyntaxCells clsEvenRow" /></tr><tr><td class="clsSyntaxCells clsOddRow"><b>getRFParams</b></td><td class="clsSyntaxCells clsOddRow">gets the current RF Mode, Transmit power parameter for the currently selected antenna. The result is return in rfParamsEvent..The property antennaSelected cannot take default value(0) because the RF Params are returned only for one antennaID.</td><td class="clsSyntaxCells clsOddRow" /></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>tagLock</b></td><td class="clsSyntaxCells clsEvenRow">Locks a tag (or tags) according to the lockPrivilege and lockField, requires tagPassword.tagID property is ignored if useAccessFilter property is set to true.If useAccessFilter is set to true, then  tagPatternA, tagPatternB and matchPattern will be used to filter out tags to perform the operation.
				If the tagID is empty and useAccessFilter is false, the lock operation will be attempted on all the tags in field of view
				</td><td class="clsSyntaxCells clsEvenRow" /></tr><tr><td class="clsSyntaxCells clsOddRow"><b>getRFModeInfo</b></td><td class="clsSyntaxCells clsOddRow">gets the RF mode information for the given RFMode index. The result is returned in a rfModeInfoEvent</td><td class="clsSyntaxCells clsOddRow" /></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>setRFParams</b></td><td class="clsSyntaxCells clsEvenRow">sets the RF mode and/or transmit power of a selected antenna</td><td class="clsSyntaxCells clsEvenRow" /></tr></table>


##Parameters


Items listed in this section indicate parameters, or attributes which can be set.
<table class="re-table"><col width="20%" /><col width="20%" /><col width="38%" /><col width="22%" /><tr><th class="tableHeading">Name</th><th class="tableHeading">Possible Values</th><th class="tableHeading">Description</th><th class="tableHeading">Default Value</th></tr><tr><td class="clsSyntaxCells clsOddRow"><b>antennaSelected:[Value]
</b></td><td class="clsSyntaxCells clsOddRow">0-N</td><td class="clsSyntaxCells clsOddRow">Index of the antenna being selected for the subsequent data or configuration operations.A '0' indicates all antennas to be selected.</td><td class="clsSyntaxCells clsOddRow">0(ALL)</td></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>beepOnRead:[Value]
</b></td><td class="clsSyntaxCells clsEvenRow">unique, all, disabled</td><td class="clsSyntaxCells clsEvenRow">Specifies if the device should beep on every tag, unique tags, or whether it is disabled.</td><td class="clsSyntaxCells clsEvenRow">unique</td></tr><tr><td class="clsSyntaxCells clsOddRow"><b>discardTagsOnInventorystop:[Value]
</b></td><td class="clsSyntaxCells clsOddRow">true, false</td><td class="clsSyntaxCells clsOddRow">Specifies if the plugin should drop the pending Tag-reports after an inventory or locateTag operation is terminated by an explicit stop method call.</td><td class="clsSyntaxCells clsOddRow">true</td></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>enableTagAccessStatus:[Value]
</b></td><td class="clsSyntaxCells clsEvenRow">true, false, 1, 0</td><td class="clsSyntaxCells clsEvenRow">Enable/Disable the access status field in the tag reports.Contains valid values for Read/Write/Lock/Kill operations</td><td class="clsSyntaxCells clsEvenRow">false</td></tr><tr><td class="clsSyntaxCells clsOddRow"><b>enableTagAntennaID:[Value]
</b></td><td class="clsSyntaxCells clsOddRow">true, false, 1, 0</td><td class="clsSyntaxCells clsOddRow">Enable/Disable the antenna ID field in the tag reports</td><td class="clsSyntaxCells clsOddRow">false</td></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>enableTagCRC:[Value]
</b></td><td class="clsSyntaxCells clsEvenRow">true, false, 1, 0</td><td class="clsSyntaxCells clsEvenRow">Enable/Disable the CRC field in the tag reports</td><td class="clsSyntaxCells clsEvenRow">false</td></tr><tr><td class="clsSyntaxCells clsOddRow"><b>enableTagXPC:[Value]
</b></td><td class="clsSyntaxCells clsOddRow">true, false, 1, 0</td><td class="clsSyntaxCells clsOddRow">Enable/Disable the XPC field in the tag reports</td><td class="clsSyntaxCells clsOddRow">false</td></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>enableTagPC:[Value]
</b></td><td class="clsSyntaxCells clsEvenRow">true, false, 1, 0</td><td class="clsSyntaxCells clsEvenRow">Enable/Disable the PC field in the tag reports</td><td class="clsSyntaxCells clsEvenRow">false</td></tr><tr><td class="clsSyntaxCells clsOddRow"><b>enableTagRSSI:[Value]
</b></td><td class="clsSyntaxCells clsOddRow">true, false, 1, 0</td><td class="clsSyntaxCells clsOddRow">Enable/Disable the RSSI data field in tag reports</td><td class="clsSyntaxCells clsOddRow">false</td></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>enableTagSeenCount:[Value]
</b></td><td class="clsSyntaxCells clsEvenRow">true, false, 1, 0</td><td class="clsSyntaxCells clsEvenRow">Enable/Disable the SeenCount field in tag reports</td><td class="clsSyntaxCells clsEvenRow">false</td></tr><tr><td class="clsSyntaxCells clsOddRow"><b>enableTagUTCTimeStamp:[Value]
</b></td><td class="clsSyntaxCells clsOddRow">true, false, 1, 0</td><td class="clsSyntaxCells clsOddRow">Enable/Disable the UTCTimeStamp data field in tag reports</td><td class="clsSyntaxCells clsOddRow">false</td></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>invMemBank:[Value]
</b></td><td class="clsSyntaxCells clsEvenRow">None, Reserved, EPC, TID, User</td><td class="clsSyntaxCells clsEvenRow">Specifies if any memory bank is to be read during an inventory</td><td class="clsSyntaxCells clsEvenRow">None</td></tr><tr><td class="clsSyntaxCells clsOddRow"><b>lockField:[Value]
</b></td><td class="clsSyntaxCells clsOddRow">killPassword, accessPassword, EPC, TID, User</td><td class="clsSyntaxCells clsOddRow">sets the data field to be used for tagLock operation</td><td class="clsSyntaxCells clsOddRow">None</td></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>lockPrivilege:[Value]
</b></td><td class="clsSyntaxCells clsEvenRow">lock, unlock, permanentLock, permanentUnlock</td><td class="clsSyntaxCells clsEvenRow">sets the lock privilege to be used for tagLock operation</td><td class="clsSyntaxCells clsEvenRow">None</td></tr><tr><td class="clsSyntaxCells clsOddRow"><b>matchPattern:[Value]
</b></td><td class="clsSyntaxCells clsOddRow">A_AND_B, NOTA_AND_B, NOTA_AND_NOTB, A_AND_NOTB, A</td><td class="clsSyntaxCells clsOddRow">Match criteria to be used for filtering using tag-patterns A and B.</td><td class="clsSyntaxCells clsOddRow">A</td></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>newTagID:[Value]
</b></td><td class="clsSyntaxCells clsEvenRow">hex password</td><td class="clsSyntaxCells clsEvenRow">sets a new tag ID to be assigned to the currently selected tag in the setTagID method</td><td class="clsSyntaxCells clsEvenRow">
N/A
</td></tr><tr><td class="clsSyntaxCells clsOddRow"><b>newAccessPassword:[Value]
</b></td><td class="clsSyntaxCells clsOddRow">hex password</td><td class="clsSyntaxCells clsOddRow">sets a new tag access password to be assigned to the currently selected tag in the setTagAccessPassword method</td><td class="clsSyntaxCells clsOddRow">
N/A
</td></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>newKillPassword:[Value]
</b></td><td class="clsSyntaxCells clsEvenRow">hex password</td><td class="clsSyntaxCells clsEvenRow">sets a new tag kill password to be assigned to the currently selected tag in the setTagKillPassword method</td><td class="clsSyntaxCells clsEvenRow">
N/A
</td></tr><tr><td class="clsSyntaxCells clsOddRow"><b>preFilterBitCount:[Value]
</b></td><td class="clsSyntaxCells clsOddRow">Number of applicable bits in the filterHexPattern</td><td class="clsSyntaxCells clsOddRow">Specifies the number of bits within the preFilterHexPattern to match in a subsequent call to addFilter()</td><td class="clsSyntaxCells clsOddRow">
N/A
</td></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>preFilterBitOffset:[Value]
</b></td><td class="clsSyntaxCells clsEvenRow">Offset from the start of the memory bank in bits</td><td class="clsSyntaxCells clsEvenRow">Specifies the offset into the memory bank (position) applicable to a subsequent call to addFilter()</td><td class="clsSyntaxCells clsEvenRow">32</td></tr><tr><td class="clsSyntaxCells clsOddRow"><b>preFilterHexPattern:[Value]
</b></td><td class="clsSyntaxCells clsOddRow">Hex Pattern</td><td class="clsSyntaxCells clsOddRow">Specifies a hex pattern to apply in a subsequent call to addFilter()</td><td class="clsSyntaxCells clsOddRow">
N/A
</td></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>preFilterID:[Value]
</b></td><td class="clsSyntaxCells clsEvenRow">unsigned integer</td><td class="clsSyntaxCells clsEvenRow">Specifies the ID of the filter to apply in a subsequent call to addFilter()`or deleteFilter()</td><td class="clsSyntaxCells clsEvenRow">
N/A
</td></tr><tr><td class="clsSyntaxCells clsOddRow"><b>preFilterMemBank:[Value]
</b></td><td class="clsSyntaxCells clsOddRow">Reserved,EPC,TID,User</td><td class="clsSyntaxCells clsOddRow">Specifies the memory bank to apply in a subsequent call to addFilter()</td><td class="clsSyntaxCells clsOddRow">EPC</td></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>startPeriod:[Value]
</b></td><td class="clsSyntaxCells clsEvenRow">milliseconds</td><td class="clsSyntaxCells clsEvenRow">Sets the repeat period for a subsequent inventory</td><td class="clsSyntaxCells clsEvenRow">
N/A
</td></tr><tr><td class="clsSyntaxCells clsOddRow"><b>reportTrigger:[Value]
</b></td><td class="clsSyntaxCells clsOddRow">0-N</td><td class="clsSyntaxCells clsOddRow">This property controls the reporting of tags from the reader. Setting this property to N indicate to the reader that it
					should report tags on seeing N unique tags.0 indicates to report tags only at
					the end of inventory.
				</td><td class="clsSyntaxCells clsOddRow">1</td></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>reportUniqueTags:[Value]
</b></td><td class="clsSyntaxCells clsEvenRow">true, false, 1, 0</td><td class="clsSyntaxCells clsEvenRow">Specifies to report only unique tags</td><td class="clsSyntaxCells clsEvenRow">true</td></tr><tr><td class="clsSyntaxCells clsOddRow"><b>RFMode:[Value]
</b></td><td class="clsSyntaxCells clsOddRow">One of the supported RF Modes listed in the capabilities (see enumRFIDEvent)</td><td class="clsSyntaxCells clsOddRow">Sets the RFMode of the currently selected antenna(e)</td><td class="clsSyntaxCells clsOddRow">
N/A
</td></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>singulationSession:[Value]
</b></td><td class="clsSyntaxCells clsEvenRow">0-3</td><td class="clsSyntaxCells clsEvenRow">Sets the singulation session parameter for the currently selected antenna(e)</td><td class="clsSyntaxCells clsEvenRow">
N/A
</td></tr><tr><td class="clsSyntaxCells clsOddRow"><b>singulationTagPopulation:[Value]
</b></td><td class="clsSyntaxCells clsOddRow">unsigned short integer</td><td class="clsSyntaxCells clsOddRow">Sets the singulation tag population parameter for the currently selected antenna(e)</td><td class="clsSyntaxCells clsOddRow">
N/A
</td></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>startTriggerType:[Value]
</b></td><td class="clsSyntaxCells clsEvenRow">immediate, triggerPress, triggerRelease, periodicStart</td><td class="clsSyntaxCells clsEvenRow">Specifies the start triggers allowed for performInventory and tagLocate methods</td><td class="clsSyntaxCells clsEvenRow">immediate</td></tr><tr><td class="clsSyntaxCells clsOddRow"><b>stopDuration:[Value]
</b></td><td class="clsSyntaxCells clsOddRow">milliseconds</td><td class="clsSyntaxCells clsOddRow">Sets the duration of a inventory or locateTag</td><td class="clsSyntaxCells clsOddRow">
N/A
</td></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>stopObservationCount:[Value]
</b></td><td class="clsSyntaxCells clsEvenRow">unsigned integer</td><td class="clsSyntaxCells clsEvenRow">Stops the inventory or locateTag after n tags are found</td><td class="clsSyntaxCells clsEvenRow">
N/A
</td></tr><tr><td class="clsSyntaxCells clsOddRow"><b>stopTriggerType:[Value]
</b></td><td class="clsSyntaxCells clsOddRow">triggerPress, triggerRelease, duration, tagObservation</td><td class="clsSyntaxCells clsOddRow">Specifies the stop-triggers allowed for performInventory and tagLocate methods</td><td class="clsSyntaxCells clsOddRow">
N/A
</td></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>tagByteOffset:[Value]
</b></td><td class="clsSyntaxCells clsEvenRow">unsigned integer</td><td class="clsSyntaxCells clsEvenRow">sets the offset into the selected memory Bank to use for the next access of the currently selected tag</td><td class="clsSyntaxCells clsEvenRow">0</td></tr><tr><td class="clsSyntaxCells clsOddRow"><b>tagID:[Value]
</b></td><td class="clsSyntaxCells clsOddRow">Tag ID in hex</td><td class="clsSyntaxCells clsOddRow">Select an RFID Tag ID to perform further operations on</td><td class="clsSyntaxCells clsOddRow">
N/A
</td></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>tagKillPassword:[Value]
</b></td><td class="clsSyntaxCells clsEvenRow">hex kill password</td><td class="clsSyntaxCells clsEvenRow">sets the password to use when calling the killTag method</td><td class="clsSyntaxCells clsEvenRow">
N/A
</td></tr><tr><td class="clsSyntaxCells clsOddRow"><b>tagMemBank:[Value]
</b></td><td class="clsSyntaxCells clsOddRow">Reserved,EPC,TID,User</td><td class="clsSyntaxCells clsOddRow">sets the memory bank to access within the currently selected tag.</td><td class="clsSyntaxCells clsOddRow">EPC</td></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>tagPassword:[Value]
</b></td><td class="clsSyntaxCells clsEvenRow">hex password</td><td class="clsSyntaxCells clsEvenRow">Sets the access password to use when accessing the currently selected tag.</td><td class="clsSyntaxCells clsEvenRow">00000000</td></tr><tr><td class="clsSyntaxCells clsOddRow"><b>tagPatternAByteOffset:[Value]
</b></td><td class="clsSyntaxCells clsOddRow">Offset from the start of the memory bank in bytes</td><td class="clsSyntaxCells clsOddRow">Specifies the offset into the memory bank (position) </td><td class="clsSyntaxCells clsOddRow">4</td></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>tagPatternAHexMask:[Value]
</b></td><td class="clsSyntaxCells clsEvenRow">Hex Mask</td><td class="clsSyntaxCells clsEvenRow">Specifies the mask for above pattern</td><td class="clsSyntaxCells clsEvenRow">
N/A
</td></tr><tr><td class="clsSyntaxCells clsOddRow"><b>tagPatternAHexPattern:[Value]
</b></td><td class="clsSyntaxCells clsOddRow">Hex Pattern</td><td class="clsSyntaxCells clsOddRow">Specifies a hex pattern to be used for comparing memory bank data</td><td class="clsSyntaxCells clsOddRow">
N/A
</td></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>tagPatternAMemBank:[Value]
</b></td><td class="clsSyntaxCells clsEvenRow">Reserved,EPC,TID,User</td><td class="clsSyntaxCells clsEvenRow">Specifies the memory bank for the tag pattern A</td><td class="clsSyntaxCells clsEvenRow">EPC</td></tr><tr><td class="clsSyntaxCells clsOddRow"><b>tagPatternBByteOffset:[Value]
</b></td><td class="clsSyntaxCells clsOddRow">Offset from the start of the memory bank in bytes</td><td class="clsSyntaxCells clsOddRow">Specifies the offset into the memory bank (position) </td><td class="clsSyntaxCells clsOddRow">4</td></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>tagPatternBHexMask:[Value]
</b></td><td class="clsSyntaxCells clsEvenRow">Hex Mask</td><td class="clsSyntaxCells clsEvenRow">Specifies the mask for above pattern</td><td class="clsSyntaxCells clsEvenRow">
N/A
</td></tr><tr><td class="clsSyntaxCells clsOddRow"><b>tagPatternBHexPattern:[Value]
</b></td><td class="clsSyntaxCells clsOddRow">Hex Pattern</td><td class="clsSyntaxCells clsOddRow">Specifies a hex pattern to be used for comparing memory bank data</td><td class="clsSyntaxCells clsOddRow">
N/A
</td></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>tagPatternBMemBank:[Value]
</b></td><td class="clsSyntaxCells clsEvenRow">Reserved,EPC,TID,User</td><td class="clsSyntaxCells clsEvenRow">Specifies the memory bank for the tag pattern B</td><td class="clsSyntaxCells clsEvenRow">EPC</td></tr><tr><td class="clsSyntaxCells clsOddRow"><b>tagReadSize:[Value]
</b></td><td class="clsSyntaxCells clsOddRow">0 (all) - N bytes</td><td class="clsSyntaxCells clsOddRow">sets the number of bytes to read in the tagRead method.</td><td class="clsSyntaxCells clsOddRow">0 (all)</td></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>tagWriteData:[Value]
</b></td><td class="clsSyntaxCells clsEvenRow">hex data</td><td class="clsSyntaxCells clsEvenRow">sets the data to write in the tagWrite method</td><td class="clsSyntaxCells clsEvenRow">
N/A
</td></tr><tr><td class="clsSyntaxCells clsOddRow"><b>transmitPower:[Value]
</b></td><td class="clsSyntaxCells clsOddRow">power in dbm derived from min, max and step values provided in the enumRFIDevent</td><td class="clsSyntaxCells clsOddRow">Specifies the transmit power to be used in a subsequent call to setTransmitPower</td><td class="clsSyntaxCells clsOddRow">
N/A
</td></tr><tr><td class="clsSyntaxCells clsEvenRow"><b>useAccessFilter:[Value]
</b></td><td class="clsSyntaxCells clsEvenRow">true, false, 1, 0</td><td class="clsSyntaxCells clsEvenRow">Specifies whether to use the access filter in tag access operations</td><td class="clsSyntaxCells clsEvenRow">false</td></tr></table>
<table class="re-table"><col width="78%" /><col width="8%" /><col width="1%" /><col width="5%" /><col width="1%" /><col width="5%" /><col width="2%" /></table>	

##Events


Values are returned to the caller in RhoElements via Events.  Most modules contain events and those returned from this module are given below along with the event parameters.  Events can cause a navigation to a new URL or a Javascript function on the page to be invoked.  Each event will in most cases have a number of parameters associated with it which will either be strings or javascript arrays.  Event parameters can be accessed either directly or via JSON objects.

<br />
###enumRFIDEvent
Enumerates the RFID readers present on the device (normally only one) along with their respective capabilities
<table class="re-table"><col width="3%" /><col width="20%" /><col width="77%" /><tr><th class="tableHeading">ID</th><th class="tableHeading">Name</th><th class="tableHeading">Description</th></tr><tr><td style="text-align:left;" class="clsSyntaxCells clsOddRow">1</td><td style="text-align:left;" class="clsSyntaxCells clsOddRow"><b>numberOfDevices</b></td><td style="text-align:left;" class="clsSyntaxCells clsOddRow">returns total number of device enumerated, returns always 1</td></tr><tr><td class="clsSyntaxCells clsEvenRow" style="text-align:left;">2</td><td class="clsSyntaxCells clsEvenRow" style="text-align:left;"><b>readerID</b></td><td class="clsSyntaxCells clsEvenRow" style="text-align:left;">ID assigned to reader</td></tr><tr><td style="text-align:left;" class="clsSyntaxCells clsOddRow">3</td><td style="text-align:left;" class="clsSyntaxCells clsOddRow"><b>firmwareVersion</b></td><td style="text-align:left;" class="clsSyntaxCells clsOddRow">Firmware version of the reader</td></tr><tr><td class="clsSyntaxCells clsEvenRow" style="text-align:left;">4</td><td class="clsSyntaxCells clsEvenRow" style="text-align:left;"><b>modelName</b></td><td class="clsSyntaxCells clsEvenRow" style="text-align:left;">Model FX, MC</td></tr><tr><td style="text-align:left;" class="clsSyntaxCells clsOddRow">5</td><td style="text-align:left;" class="clsSyntaxCells clsOddRow"><b>numberOfAntennas</b></td><td style="text-align:left;" class="clsSyntaxCells clsOddRow">Antennas supported/connected by/to reader</td></tr><tr><td class="clsSyntaxCells clsEvenRow" style="text-align:left;">6</td><td class="clsSyntaxCells clsEvenRow" style="text-align:left;"><b>numberOfPreFilters</b></td><td class="clsSyntaxCells clsEvenRow" style="text-align:left;">Total number of pre-filters available </td></tr><tr><td style="text-align:left;" class="clsSyntaxCells clsOddRow">7</td><td style="text-align:left;" class="clsSyntaxCells clsOddRow"><b>countryCode</b></td><td style="text-align:left;" class="clsSyntaxCells clsOddRow">region configured</td></tr><tr><td class="clsSyntaxCells clsEvenRow" style="text-align:left;">8</td><td class="clsSyntaxCells clsEvenRow" style="text-align:left;"><b>communicationStandard</b></td><td class="clsSyntaxCells clsEvenRow" style="text-align:left;">country/region frequency band standards</td></tr><tr><td style="text-align:left;" class="clsSyntaxCells clsOddRow">9</td><td style="text-align:left;" class="clsSyntaxCells clsOddRow"><b>transmitPowerMin</b></td><td style="text-align:left;" class="clsSyntaxCells clsOddRow">Minimum transmit power supported by reader 500dbm</td></tr><tr><td class="clsSyntaxCells clsEvenRow" style="text-align:left;">10</td><td class="clsSyntaxCells clsEvenRow" style="text-align:left;"><b>transmitPowerMax</b></td><td class="clsSyntaxCells clsEvenRow" style="text-align:left;">Maximum transmit power supported by reader 3000dbm</td></tr><tr><td style="text-align:left;" class="clsSyntaxCells clsOddRow">11</td><td style="text-align:left;" class="clsSyntaxCells clsOddRow"><b>transmitPowerStep</b></td><td style="text-align:left;" class="clsSyntaxCells clsOddRow">Transmit power can be set in multiple of value - step</td></tr><tr><td class="clsSyntaxCells clsEvenRow" style="text-align:left;">12</td><td class="clsSyntaxCells clsEvenRow" style="text-align:left;"><b>numberOfRFModes</b></td><td class="clsSyntaxCells clsEvenRow" style="text-align:left;">Number of supported RFModes</td></tr></table>
<br />
###rfParamsEvent
Returns RF Parameter values- Transmit Power and RF Mode of a selected antenna
<table class="re-table"><col width="3%" /><col width="20%" /><col width="77%" /><tr><th class="tableHeading">ID</th><th class="tableHeading">Name</th><th class="tableHeading">Description</th></tr><tr><td style="text-align:left;" class="clsSyntaxCells clsOddRow">1</td><td style="text-align:left;" class="clsSyntaxCells clsOddRow"><b>transmitPower</b></td><td style="text-align:left;" class="clsSyntaxCells clsOddRow">radiated power in db</td></tr><tr><td class="clsSyntaxCells clsEvenRow" style="text-align:left;">2</td><td class="clsSyntaxCells clsEvenRow" style="text-align:left;"><b>RFMode</b></td><td class="clsSyntaxCells clsEvenRow" style="text-align:left;">RF Mode Table Index</td></tr></table>
<br />
###rfModeInfoEvent
Returns the RF Characteristics for a particular RF Mode
<table class="re-table"><col width="3%" /><col width="20%" /><col width="77%" /><tr><th class="tableHeading">ID</th><th class="tableHeading">Name</th><th class="tableHeading">Description</th></tr><tr><td style="text-align:left;" class="clsSyntaxCells clsOddRow">1</td><td style="text-align:left;" class="clsSyntaxCells clsOddRow"><b>modeIdentifier</b></td><td style="text-align:left;" class="clsSyntaxCells clsOddRow">Refer to EPC-Global's definition</td></tr><tr><td class="clsSyntaxCells clsEvenRow" style="text-align:left;">2</td><td class="clsSyntaxCells clsEvenRow" style="text-align:left;"><b>divideRatio</b></td><td class="clsSyntaxCells clsEvenRow" style="text-align:left;">Refer to EPC-Global's definition</td></tr><tr><td style="text-align:left;" class="clsSyntaxCells clsOddRow">3</td><td style="text-align:left;" class="clsSyntaxCells clsOddRow"><b>bdrValue</b></td><td style="text-align:left;" class="clsSyntaxCells clsOddRow">Refer to EPC-Global's definition</td></tr><tr><td class="clsSyntaxCells clsEvenRow" style="text-align:left;">4</td><td class="clsSyntaxCells clsEvenRow" style="text-align:left;"><b>modulation</b></td><td class="clsSyntaxCells clsEvenRow" style="text-align:left;">Refer to EPC-Global's definition</td></tr><tr><td style="text-align:left;" class="clsSyntaxCells clsOddRow">5</td><td style="text-align:left;" class="clsSyntaxCells clsOddRow"><b>forwardLinkModulationType</b></td><td style="text-align:left;" class="clsSyntaxCells clsOddRow">Refer to EPC-Global's definition</td></tr><tr><td class="clsSyntaxCells clsEvenRow" style="text-align:left;">6</td><td class="clsSyntaxCells clsEvenRow" style="text-align:left;"><b>pieValue</b></td><td class="clsSyntaxCells clsEvenRow" style="text-align:left;">Refer to EPC-Global's definition</td></tr><tr><td style="text-align:left;" class="clsSyntaxCells clsOddRow">7</td><td style="text-align:left;" class="clsSyntaxCells clsOddRow"><b>minTariValue</b></td><td style="text-align:left;" class="clsSyntaxCells clsOddRow">Refer to EPC-Global's definition</td></tr><tr><td class="clsSyntaxCells clsEvenRow" style="text-align:left;">8</td><td class="clsSyntaxCells clsEvenRow" style="text-align:left;"><b>maxTariValue</b></td><td class="clsSyntaxCells clsEvenRow" style="text-align:left;">Refer to EPC-Global's definition</td></tr><tr><td style="text-align:left;" class="clsSyntaxCells clsOddRow">9</td><td style="text-align:left;" class="clsSyntaxCells clsOddRow"><b>stepTariValue</b></td><td style="text-align:left;" class="clsSyntaxCells clsOddRow">Refer to EPC-Global's definition</td></tr><tr><td class="clsSyntaxCells clsEvenRow" style="text-align:left;">10</td><td class="clsSyntaxCells clsEvenRow" style="text-align:left;"><b>spectralMaskIndicator</b></td><td class="clsSyntaxCells clsEvenRow" style="text-align:left;">Refer to EPC-Global's definition</td></tr><tr><td style="text-align:left;" class="clsSyntaxCells clsOddRow">11</td><td style="text-align:left;" class="clsSyntaxCells clsOddRow"><b>epcHAGTCConformance</b></td><td style="text-align:left;" class="clsSyntaxCells clsOddRow">Refer to EPC-Global's definition</td></tr></table>
<br />
###tagEvent
Returns received RFID tag data from a single tag
<table class="re-table"><col width="3%" /><col width="20%" /><col width="77%" /><tr><th class="tableHeading">ID</th><th class="tableHeading">Name</th><th class="tableHeading">Description</th></tr><tr><td style="text-align:left;" class="clsSyntaxCells clsOddRow">1</td><td style="text-align:left;" class="clsSyntaxCells clsOddRow"><b>TagData (tagID, PC, tagSeenCount, memoryBankData, XPC, CRC, antennaID, 
						RSSI, accessStatus, relativeDistance, firstSeenTimeStamp)</b></td><td style="text-align:left;" class="clsSyntaxCells clsOddRow">Tag data array with various parameter of read tag TagData[1..N] </td></tr></table>
<br />
###radioPowerStateEvent
Returns 1 if the radio is ON and 0 if the radio is off
<table class="re-table"><col width="3%" /><col width="20%" /><col width="77%" /><tr><th class="tableHeading">ID</th><th class="tableHeading">Name</th><th class="tableHeading">Description</th></tr><tr><td style="text-align:left;" class="clsSyntaxCells clsOddRow">1</td><td style="text-align:left;" class="clsSyntaxCells clsOddRow"><b>powerState</b></td><td style="text-align:left;" class="clsSyntaxCells clsOddRow">Radio is on/off</td></tr></table>
<br />
###statusEvent
Returns any error conditions where required
<table class="re-table"><col width="3%" /><col width="20%" /><col width="77%" /><tr><th class="tableHeading">ID</th><th class="tableHeading">Name</th><th class="tableHeading">Description</th></tr><tr><td style="text-align:left;" class="clsSyntaxCells clsOddRow">1</td><td style="text-align:left;" class="clsSyntaxCells clsOddRow"><b>method</b></td><td style="text-align:left;" class="clsSyntaxCells clsOddRow">Name of method where exactly error was generated</td></tr><tr><td class="clsSyntaxCells clsEvenRow" style="text-align:left;">2</td><td class="clsSyntaxCells clsEvenRow" style="text-align:left;"><b>errorCode</b></td><td class="clsSyntaxCells clsEvenRow" style="text-align:left;">standard RFID API error code or a plugin specific error code.
					Plugin Error code   Description
					2000  			One of the relevant parameters is invalid or missing
					2001			Plugin Busy
					2002			Failed to create a plugin thread.
					2003      		Plugin Cannot process properties or methods unless connected
					</td></tr><tr><td style="text-align:left;" class="clsSyntaxCells clsOddRow">3</td><td style="text-align:left;" class="clsSyntaxCells clsOddRow"><b>vendorMessage</b></td><td style="text-align:left;" class="clsSyntaxCells clsOddRow">Additional Error Info if any</td></tr></table>
<br />
###singulationEvent
Returns singulation values
<table class="re-table"><col width="3%" /><col width="20%" /><col width="77%" /><tr><th class="tableHeading">ID</th><th class="tableHeading">Name</th><th class="tableHeading">Description</th></tr><tr><td style="text-align:left;" class="clsSyntaxCells clsOddRow">1</td><td style="text-align:left;" class="clsSyntaxCells clsOddRow"><b>singulationSession</b></td><td style="text-align:left;" class="clsSyntaxCells clsOddRow">Refer to EPC-Global's definition</td></tr><tr><td class="clsSyntaxCells clsEvenRow" style="text-align:left;">2</td><td class="clsSyntaxCells clsEvenRow" style="text-align:left;"><b>singulationTagPopulation</b></td><td class="clsSyntaxCells clsEvenRow" style="text-align:left;">Refer to EPC-Global's definition</td></tr></table>





##Requirements

<table class="re-table"><tr><th class="tableHeading">RhoElements Version</th><td class="clsSyntaxCell clsEvenRow">2.2 or above
</td></tr><tr><th class="tableHeading">Supported Devices</th><td class="clsSyntaxCell clsOddRow">All devices</td></tr><tr><th class="tableHeading">Minimum Requirements</th><td class="clsSyntaxCell clsOddRow">Hardware for reading RFID Tags</td></tr><tr><th class="tableHeading">Persistence</th><td class="clsSyntaxCell clsEvenRow">Not Persistent - Changes to this module will not persist when navigating to a new page.</td></tr></table>


##HTML/Javascript Examples

This example starts an inventory using HTTP Meta Tags and tags are sent to a javascript function "TagHandler".

	<META HTTP-Equiv="rfid" content="statusEvent:url('javascript:statusHandler(%json)')">
	<META HTTP-Equiv="rfid" content="tagEvent:url('javascript:TagHandler(%json)')">
	<META HTTP-Equiv="rfid" content="performInventory">
	<script>
	// Function to handle a tagReport containing only tagID field
	function TagHandler(tagReportJSON)
	{
	   objGeneric.Log("TagID read:"+tagReportJSON.TagData[0].tagID,3);
	}
	</script>	
			
			
This example runs inventory as long as trigger button is pressed. By default,the plugin reports unique tags to tagEvent callback in JSON format and beeps for every unique tag encountered.By default, only one tagID is reported per the JSON tagReport. Besides,this JSON contains only the field tagID.

	<script>
	var objGeneric = new ActiveXObject("PocketBrowser.Generic");   
	objGeneric.InvokeMETAFunction("OnTrigger", "javascript:doTrigger('%s')");
	rfid.statusEvent = "statusHandler(%json)";
	
	function doTrigger(state) 
	{
	
	  if(state == 0)
	  {	
		  rfid.stop();
	  }
	  else
	  {
		  rfid.tagEvent =  "TagHandler(%json)";
		  rfid.performInventory();
	  }
	}
	
	// Function to handle a tagReport containing only tagID field
	function TagHandler(tagReportJSON)
	{
	   objGeneric.Log("TagID read:"+tagReportJSON.TagData[0].tagID,3);
	}
	
	
	function statusHandler(statusJSON)
	{
	  objGeneric.Log("Status:"+statusJSON.method+'  '+statusJSON.errorCode,1);
	}
	
	</script>	
					
This example performs inventory with start and stop triggers configured.Here all the tag-reads are reported to tagEvent callback with 5 reports per callback. Besides,the tagSeenCount and the UTCTtimestamp at which tag was first seen is also reported.Note:It will still beep for only unique tags read.

	<script>
	var objGeneric = new ActiveXObject("PocketBrowser.Generic");   
	rfid.statusEvent = "statusHandler(%json)";
	
	function performAdvancedInventory1()
	{
		rfid.tagEvent =  "TagHandlerAdvanced1(%json)";
		rfid.reportUniqueTags = false;
		rfid.reportTrigger = 5;
		rfid.enableTagSeenCount = true;
		rfid.enableTagUTCTimeStamp = true;
		rfid.startTriggerType = "triggerPress";
		rfid.stopTriggerType = "duration";
		rfid.stopDuration = 10000;// Duration in milliseconds.
		rfid.performInventory();
	}
	
	// Function to handle tagReports containing tagID,seenCount and firstSeenTimeStamp fields.
	function TagHandlerAdvanced1(tagReportJSON)
	{
	   objGeneric.Log("TagID :"+tagReportJSON.TagData[0].tagID+" Seen Count: "+tagReportJSON.TagData[0].tagSeenCount+" First seen Timestamp:"+tagReportJSON.TagData[0].firstSeenTimeStamp,3);
	   objGeneric.Log("TagID :"+tagReportJSON.TagData[1].tagID+" Seen Count: "+tagReportJSON.TagData[1].tagSeenCount+" First seen Timestamp:"+tagReportJSON.TagData[1].firstSeenTimeStamp,3);
	   objGeneric.Log("TagID :"+tagReportJSON.TagData[2].tagID+" Seen Count: "+tagReportJSON.TagData[2].tagSeenCount+" First seen Timestamp:"+tagReportJSON.TagData[2].firstSeenTimeStamp,3);
	   objGeneric.Log("TagID :"+tagReportJSON.TagData[3].tagID+" Seen Count: "+tagReportJSON.TagData[3].tagSeenCount+" First seen Timestamp:"+tagReportJSON.TagData[3].firstSeenTimeStamp,3);
	   objGeneric.Log("TagID :"+tagReportJSON.TagData[4].tagID+" Seen Count: "+tagReportJSON.TagData[4].tagSeenCount+" First seen Timestamp:"+tagReportJSON.TagData[4].firstSeenTimeStamp,3);
	}
	
	function statusHandler(statusJSON)
	{
	   objGeneric.Log("Status:"+statusJSON.method+'  '+statusJSON.errorCode,1);
	}
	</script>					
					
This example performs inventory and reads the Reserved memory Bank of all tags inventoried.The tags are selected to match a particular pre-filter pattern(EPC starts with "9742") The tagEvent handler extracts both tagID and memoryBankData fields. Inventory is stopped after 10 tag-reads are observed

	<script>
	var objGeneric = new ActiveXObject("PocketBrowser.Generic");   
	rfid.statusEvent = "statusHandler(%json)";
	
	function performAdvancedInventory2()
	{
		rfid.tagEvent =  "TagHandlerAdvanced2(%json)";
		rfid.stopTriggerType = "tagObservation";
		rfid.stopObservationCount = 10;
		rfid.preFilterID = 1;
		rfid.preFilterMemBank = "EPC";
		rfid.preFilterBitOffset = 32;
		rfid.preFilterHexPattern = "9742";
		rfid.preFilterBitCount = 16;
		rfid.addPreFilter();
		rfid.invMemBank = "Reserved";	
		rfid.performInventory();
	}
	
	// Function to handle tagReports containing tagID,seenCount and firstSeenTimeStamp fields.
	function TagHandlerAdvanced2(tagReportJSON)
	{
	   objGeneric.Log("TagID :"+tagReportJSON.TagData[0].tagID+" Reserved MemoryBank Data: "+tagReportJSON.TagData[0].memoryBankData,1);
	}
	
	function statusHandler(statusJSON)
	{
	   objGeneric.Log("Status:"+statusJSON.method+'  '+statusJSON.errorCode,1);
	}
	</script>					
					
This example gets the capabilities of the local RFID Module and configures the antenna's RF and Singulation parameters. The application should register Javascript callbacks for the enumRFIDEvent and rfParamsEvent events.

	<script>
	var objGeneric = new ActiveXObject("PocketBrowser.Generic");   
	rfid.statusEvent = "statusHandler(%json)";
	
	function EnumerateRFIDModule()
	{
	  rfid.enumRFIDEvent = "enumerateRFIDHandler(%json)";
	  objGeneric.Log("In EnumerateRFIDModule :",3);
	  rfid.enumerate();
	  ConfigureRFIDModule();
	}
	
	function enumerateRFIDHandler(enumRFIDJSON)
	{
	  objGeneric.Log("Number of Devices:"+enumRFIDJSON.numberOfDevices,3);
	  objGeneric.Log("Reader ID:"+enumRFIDJSON.readerID,3);
	  objGeneric.Log("Firmware version:"+enumRFIDJSON.firmwareVersion,3);
	  objGeneric.Log("Model Name:"+enumRFIDJSON.modelName,3);
	  objGeneric.Log("Number of Antennas:"+enumRFIDJSON.numberOfAntennas,3);
	  objGeneric.Log("Number of Prefilters:"+enumRFIDJSON.numberOfPreFilters,3);
	  objGeneric.Log("Country code:"+enumRFIDJSON.countryCode,3);
	  objGeneric.Log("Communication standard:"+enumRFIDJSON.communicationStandard,3);
	  objGeneric.Log("Minimum Transmit Power:"+enumRFIDJSON.transmitPowerMin,3);
	  objGeneric.Log("Maximum Transmit Power:"+enumRFIDJSON.transmitPowerMax,3);
	  objGeneric.Log("Step Transmit Power:"+enumRFIDJSON.transmitPowerStep,3);
	  objGeneric.Log("Supported RF Modes:"+enumRFIDJSON.numberOfRFModes,3);
	}
	
	function ConfigureRFIDModule()
	{
	  rfid.singulationEvent = "getSingulationHandler(%json)";
	  rfid.rfParamsEvent = "getRFParamsHandler(%json)";
	
	  rfid.singulationSession  = "1";
	  rfid.singulationTagPopulation = "100";
	
	  rfid.RFMode = "4";             // Mode table Index
	  rfid.transmitPower = "25.20";  // Transmit Power in dbM
	
	  rfid.setSingulation(); // Applies on both the antennas.
	  rfid.setRFParams();
	
	  rfid.antennaSelected = 1;  // To verify if the settings have indeed been applied.
	  rfid.getSingulation();
	  rfid.getRFParams();
	}
	
	function getRFParamsHandler(RFParamsJSON)
	{
	  objGeneric.Log("RFMode of Antenna 1:"+RFParamsJSON.RFMode,3);
	  objGeneric.Log("Transmit Power of Antenna 1:"+RFParamsJSON.transmitPower,3);
	}
	
	function getSingulationHandler(singulationJSON)
	{
	  objGeneric.Log("Session of Antenna 1:"+singulationJSON.singulationSession,3);
	  objGeneric.Log("Tag Population of Antenna 1:"+singulationJSON.singulationTagPopulation,3);
	}
	
	function statusHandler(statusJSON)
	{
	  objGeneric.Log("Status:"+statusJSON.method+'  '+statusJSON.errorCode,1);
	}
	</script>					
				  
This example performs TagLocationing operation and reports the real-time relative distance information of the tag being located.

	<script>
	var objGeneric = new ActiveXObject("PocketBrowser.Generic");   
	rfid.statusEvent = "statusHandler(%json)";
	
	function TagLocationing()
	{
		rfid.tagEvent = "TagLocateHandler(%json)";
		rfid.antennaSelected = 1;
		rfid.tagID = "97427423111111111111111111111111111111111111111111111111";
		rfid.locateTag();
		setTimeout("stopRunningLocate()",10000);
	}
	function stopRunningLocate()
	{
		rfid.stop();
	  
	}
	function TagLocateHandler(tagReportJSON)
	{
		objGeneric.Log("TagID :"+tagReportJSON.TagData[0].tagID+" Relative Distance: "+tagReportJSON.TagData[0].relativeDistance,1);
	}
	
	function statusHandler(statusJSON)
	{
	   objGeneric.Log("Status:"+statusJSON.method+'  '+statusJSON.errorCode,1);
	}
	</script>					
					
This example performs Read operation on a particular tagID .

	<script>
	var objGeneric = new ActiveXObject("PocketBrowser.Generic");   
	rfid.statusEvent = "statusHandler(%json)";
	
	function readSingleTag()
	{
		rfid.tagID = "97427423111111111111111111111111111111111111111111111111";
		rfid.tagEvent =  "TagMemBankHandler(%json)";
		rfid.tagByteOffset = 4;
		rfid.tagMemBank = "Reserved";
		rfid.tagReadSize = 4;
		rfid.tagRead();
	}
	function TagMemBankHandler(tagReportJSON)
	{
	  objGeneric.Log("TagID :"+tagReportJSON.TagData[0].tagID+" Access Password: "+tagReportJSON.TagData[0].memoryBankData,1);
	}
	
	function statusHandler(statusJSON)
	{
	   objGeneric.Log("Status:"+statusJSON.method+'  '+statusJSON.errorCode,1);
	}
	</script>					
					
This example performs Read operation on all tags that match a particular tagPattern(access-filter).Reads User memory bank of all tags whose EPC start with "9742".

	<script>
	var objGeneric = new ActiveXObject("PocketBrowser.Generic");
	rfid.statusEvent = "statusHandler(%json)";
	function testReadMultipleTags()
	{
	  var selectedTagPattern = "9742";
	  var hexMaskStr = "";var i =0;
	  for(i =0;i < selectedTagPattern.length;i++)
	  hexMaskStr += "F";
	
	  rfid.useAccessFilter = true;
	  rfid.matchPattern = "A";
	  rfid.tagPatternAMemBank = "EPC";
	  rfid.tagPatternAByteOffset = 4;
	  rfid.tagPatternAHexPattern = selectedTagPattern;
	  rfid.tagPatternAHexMask = hexMaskStr.toString();
	  hexMaskStr = "";
	  for(i=0;i < selectedTagPattern.length;i++)
	  hexMaskStr += "F";
	
	  rfid.tagByteOffset = 0;
	  rfid.tagMemBank = "User";
	  rfid.tagReadSize = 0;
	  rfid.tagEvent =  "TagMemBankHandler(%json)";
	  rfid.tagRead();
	}
	
	function TagMemBankHandler(tagReportJSON)
	{
	  objGeneric.Log("TagID :"+tagReportJSON.TagData[0].tagID+" User Memory Data: "+tagReportJSON.TagData[0].memoryBankData,1);
	}
	
	function statusHandler(statusJSON)
	{
	  objGeneric.Log("Status:"+statusJSON.method+'  '+statusJSON.errorCode,1);
	}
	</script>					
					


