<div class='tableofcontents'> </div><h1>Rhom Synchronization</h1>

<!-- TBD - Tweak this for EB and move any images to local imagees folder -->


<p>As we&rsquo;ve shown in the <a href="../../2.2.0/rhodes/rhom">Rhom section</a>, adding synchronized data via RhoConnect to your Rhodes application is as simple as generating a model and enabling a <code>:sync</code> flag.  This triggers the internal Rhodes sync system called the <a href="https://developer.motorolasolutions.com/docs/DOC-2453"><strong><code>RhoConnectClient</code></strong></a> to synchronize data for the model and transparently handle bi-directional updates between the Rhodes application and the RhoConnect server.</p>

<p>This section covers in detail how the RhoConnectClient works in Rhodes and how you can use its flexible APIs to build data-rich native applications.</p>

<h2>Sync Workflow</h2>

<p>The RhoConnectClient interacts with RhoConnect over http(s) using <a href="http://www.json.org/">JSON</a> as a data exchange format.  With the exception of <a href="../rhoconnect/bulk-sync">bulk sync</a>, pages of synchronized data, or &ldquo;sync pages&rdquo; as we will refer to them here, are sent as JSON from RhoConnect to the RhoConnectClient.</p>

<p>Below is a simplified diagram of the RhoConnectClient workflow:</p>

<p><img src="https://s3.amazonaws.com/rhodocs/guide/synchronization/sync-flow.png"></p>

<p>This workflow consists of the following steps:</p>

<ul>
<li><p>RhoConnectClient sends authentication request to RhoConnect via <a href="../api/RhoConnectClient#mlogin"><code>RhoConnectClient.login</code></a>.  RhoConnect calls <a href="../rhoconnect/authentication"><code>Application.authenticate</code></a> with supplied credentials and returns <code>true</code> or <code>false</code>.</p></li>
<li><p>If this is a new client (i.e. fresh install or reset), the RhoConnectClient will initialize with RhoConnect:</p>

<ul>
<li><p>It requests a new unique id (client id) from RhoConnect.  This id will be referenced throughout the sync process.</p></li>
<li><p>It will register platform information with RhoConnect.  If this is a <a href="device-caps#push-notifications">push-enabled application</a> application, the RhoConnectClient will send additional information like device push pin.</p></li>
</ul>
</li>
<li><p>RhoConnectClient requests sync pages from RhoConnect, one model(or <a href="rhom">Rhom</a> model) at a time.  The order the models are synchronized is determined by the model&rsquo;s <a href="rhom#property-bag"><code>:sync_priority</code></a>, or determined automatically by the RhoConnectClient.</p></li>
</ul>


<h2>Sync Authentication</h2>

<p>When you generate a Rhodes application, you&rsquo;ll notice there is an included directory called <code>app/Settings</code>.  This contains a default <code>settings_controller.rb</code> and some views to manage authentication with <a href="../rhoconnect/introduction">RhoConnect</a>.</p>

<h3><code>login</code></h3>

<p>In <code>settings_controller.rb#do_login</code>, the <a href="../api/RhoConnectClient#mlogin"><code>RhoConnectClient.login</code></a> method is called:</p>

<pre name="code" class="ruby">RhoConnectClient.login(
    @params['login'], 
    @params['password'], 
    url_for(:action =&gt; :login_callback) 
)
</pre>

<p>Here login is called with the <code>login</code> and <code>password</code> provided by the <code>login.erb</code> form.  A <code>:login_callback</code> action is declared to handle the asynchronous result of the <a href="../api/RhoConnectClient#mlogin"><code>RhoConnectClient.login</code></a> request.</p>

<h3><code>login_callback</code></h3>

<p>When <a href="../api/RhoConnectClient#mlogin"><code>RhoConnectClient.login</code></a> completes, the callback declared is executed and receives parameters including success or failure and error messages (if any).</p>

<pre name="code" class="ruby">def login_callback
    error_code = @params['error_code'].to_i
    if error_code == 0
        # run sync if we were successful
        WebView.navigate Rho::RhoConfig.options_path
        RhoConnectClient.dosync
    else
        if error_code == Rho::RhoError::ERR_CUSTOMSYNCSERVER
            @msg = @params['error_message']
        end

        if not @msg or @msg.length == 0   
            @msg = Rho::RhoError.new(error_code).message
        end

        WebView.navigate( url_for(:action =&gt; :login, :query =&gt; {:msg =&gt; @msg}) )
    end
end
</pre>

<p>This sample checks the login <code>error_code</code>, if it is <code>0</code>, perform a full sync and render the settings page.  Otherwise, it sets up an error message and re-displays the login page with an error.</p>

<h2>Notifications</h2>

<p>The RhoConnectClient system uses notifications to provide information about the sync process to a Rhodes application. Notifications can be setup once for the duration of runtime or each time a sync is triggered.  One a sync is processing for a model, notifications are called with parameters containing sync process state.  Your application can use this information to display different wait pages, progress bars, etc. Below are two flowcharts describing the notification process during sync along with details of each of the steps. Each part in the flow chart also has an associated section below the two charts for even more in-depth description.</p>

<h3>Notifications Flow</h3>

<p>The flow charts below shows the logic flow for notifications concerning model sync. Bulk sync and incremental sync are handled differently and therefore are illustrated in two separate flow charts. The details of each step are spelled out further down this page.</p>

<div class="row-fluid">
    <div class="span6">
        <p style="text-align:center"><b>Incremental Sync</b></p>
        <img src="https://s3.amazonaws.com/rhodocs/guide/synchronization/incremental-sync.png">
    </div>
    <div class="span6">
        <p style="text-align:center"><b>Bulk Sync</b></p>
        <img src="https://s3.amazonaws.com/rhodocs/guide/synchronization/bulk-sync.png">
    </div>
</div>


<p>It is important to note that, for bulk sync, the value of <code>@params["status"]</code> will only ever be &ldquo;in_progress&rdquo;, &ldquo;error&rdquo;, or &ldquo;complete&rdquo;. There is no step in the process that will return an <code>@params["status"]</code> of &ldquo;ok&rdquo; status. Instead, <code>@params["bulk_status"]</code> (described in detail below) can be accessed to get the status of the bulk sync job. This is done because of the asynchronous nature of the bulk sync process.</p>

<h3>Set Notifications</h3>

<p>To set a notification for a model, you can use the <a href="../api/RhoConnectClient#msetNotification">setNotification</a> method using this syntax <code>RhoConnectClient.setNotification(STRING sourceName, CallBackHandler callback)</code>:</p>

<pre name="code" class="ruby">RhoConnectClient.setNotification(
    Account.get_source_name,
    url_for(:action =&gt; :sync_notify),
    "sync_complete=true"
)
</pre>

<p>Which is the same as:</p>

<pre name="code" class="ruby">Account.setNotification(
    url_for(:action =&gt; :sync_notify),
    "sync_complete=true"
)
</pre>

<p>In this example, once the sync process for the <code>Account</code> model is complete, the view will be directed to the <code>Account.sync_notify()</code> action (with params &lsquo;sync_complete=true&rsquo;) if user is on the same page. The <code>Account.sync_notify()</code> action is scaffolded by default in Ruby, in JavaScript, the action must be implemented in order to use it.</p>

<p><strong>NOTE: In these examples, after the sync is complete the notifications are removed.</strong></p>

<p>You can also set a notification for all models:</p>

<pre name="code" class="ruby">RhoConnectClient.setNotification(
    "*", url_for(:action =&gt; :sync_notify),
    "sync_complete=true"
)
</pre>

<p><strong>NOTE: This notification will not be removed automatically.</strong></p>

<h3>Notification Parameters</h3>

<p>When the notification is called, it will receive a variable called <code>@params</code>, just like a normal Rhodes controller action.</p>

<h4>Common Parameters</h4>

<p>These parameters are included in all notifications.</p>

<ul>
<li><code>@params["source_id"]</code> &ndash; The id of the current model that is synchronizing.</li>
<li><code>@params["source_name"]</code> &ndash; Name of the model (i.e. &ldquo;Product&rdquo;)</li>
<li><code>@params["sync_type"]</code> &ndash; Type of sync used for this model: &ldquo;incremental&rdquo; or &ldquo;bulk&rdquo;</li>
<li><code>@params["status"]</code> &ndash; Status of the current sync process: &ldquo;in_progress&rdquo;, &ldquo;error&rdquo;, &ldquo;ok&rdquo;, &ldquo;complete&rdquo;, &ldquo;schema-changed&rdquo;</li>
</ul>


<h4>&ldquo;in_progress&rdquo; &ndash; incremental sync</h4>

<ul>
<li><code>@params["total_count"]</code> &ndash; Total number of records that exist for this RhoConnect source.</li>
<li><code>@params["processed_count"]</code> &ndash; Number of records included in the sync page.</li>
<li><code>@params["cumulative_count"]</code> &ndash; Number of records the RhoConnectClient has processed so far for this source.</li>
</ul>


<h4>&ldquo;in_progress&rdquo; &ndash; bulk sync</h4>

<ul>
<li><p><code>@params["bulk_status"]</code> &ndash; The state of the bulk sync process:</p>

<ul>
<li>&ldquo;start&rdquo;: when bulk sync start and when specific partition is start syncing</li>
<li>&ldquo;download&rdquo;: when client start downloading database from server</li>
<li>&ldquo;change_db&rdquo;: when client start applying new database</li>
<li>&ldquo;blobs&rdquo;: when client start downloading remote blob files</li>
<li>&ldquo;ok&rdquo;: when sync of partition finished without error</li>
<li>&ldquo;complete&rdquo;: when bulk sync finished for all partitions without errors</li>
</ul>
</li>
<li><p><code>@params["partition"]</code> &ndash; Current bulk sync partition.</p></li>
</ul>


<h4>&ldquo;error&rdquo;</h4>

<ul>
<li><code>@params["error_code"]</code> &ndash; HTTP response code of the RhoConnect server error: 401, 500, 404, etc.</li>
<li><code>@params["error_message"]</code> &ndash; Response body (if any)</li>
<li><code>@params["server_errors"]</code> &ndash; Hash of &lt;model&gt; objects of RhoConnect adapter error (if exists): &ldquo;login-error&rdquo;, &ldquo;query-error&rdquo;, &ldquo;create-error&rdquo;, &ldquo;update-error&rdquo;, &ldquo;delete-error&rdquo;, &ldquo;logoff-error&rdquo;.

<ul>
<li>For <strong>&ldquo;login-error&rdquo;</strong>, <strong>&ldquo;query-error&rdquo;</strong>, <strong>&ldquo;logoff-error&rdquo;</strong>:

<ul>
<li>&lt;model&gt; object is a hash containing a &ldquo;message&rdquo; from server &ndash; <code>@params["server_errors"]["query-error"]['message']</code></li>
</ul>
</li>
<li>For <strong>&ldquo;create-error&rdquo;</strong>, <strong>&ldquo;update-error&rdquo;</strong>, <strong>&ldquo;delete-error&rdquo;</strong>:

<ul>
<li>&lt;model&gt; object is hash each containing an &ldquo;object&rdquo; as a key (that failed to create) and a corresponding &ldquo;message&rdquo; and &ldquo;attributes&rdquo;:

<ul>
<li><code>@params["server_errors"]["create-error"][object]['message']</code></li>
<li><code>@params["server_errors"]["create-error"][object]['attributes']</code></li>
</ul>
</li>
<li>These errors should be handled by their respective on_sync<em>*</em>error method in the <a href="https://developer.motorolasolutions.com/docs/DOC-2453">RhoConnectClient API</a></li>
</ul>
</li>
</ul>
</li>
</ul>


<p><strong>NOTE: &ldquo;create-error&rdquo; has to be handled in sync callback. Otherwise sync will stop on this model. To fix create errors you should call <a href="../api/RhoConnectClient#mon_sync_create_error">RhoConnectClient.on_sync_create_error</a></strong></p>

<h4>&ldquo;ok&rdquo;</h4>

<ul>
<li><code>@params["total_count"]</code> &ndash; Total number of records that exist for this RhoConnect source.</li>
<li><code>@params["processed_count"]</code> &ndash; Number of records included in the last sync page.</li>
<li><code>@params["cumulative_count"]</code> &ndash; Number of records the RhoConnectClient has processed so far for this source.</li>
</ul>


<h4>&ldquo;complete&rdquo;</h4>

<p>This status returns only when the RhoConnectClient process is complete.</p>

<h4>&ldquo;schema-changed&rdquo;</h4>

<p>This status returns for bulk-sync models that use <a href="rhom#fixed-schema"><code>FixedSchema</code></a> when the schema has changed in the RhoConnect server.</p>

<p><strong>NOTE: In this scenario the sync callback should notify the user with a wait screen and start the bulk sync process.</strong></p>

<h3>Server error processing on client</h3>

<h4>create-error</h4>

<p>has to be handled in sync callback. Otherwise sync will stop on this model. To fix create errors you should call Model.on_sync_create_error or RhoConnectClient.on_sync_create_error:</p>

<pre name="code" class="ruby">RhoConnectClient.on_sync_create_error( src_name, objects, action )
Model.on_sync_create_error( objects, action )

    * objects - One or more error objects
    * action - May be :delete or :recreate. :delete just remove object from client, :recreate will push this object to server again at next sync.
</pre>

<h4>update-error</h4>

<p>If not handled, local modifications, which were failing on server, will never sync to server again.
So sync will work fine, but nobody will know about these changes.</p>

<pre name="code" class="ruby">RhoConnectClient.on_sync_update_error( src_name, objects, action, rollback_objects = nil )
Model.on_sync_update_error( objects, action, rollback_objects = nil)

    * objects - One or more error objects
    * action - May be :retry or :rollback. :retry will push update object operation to server again at next sync, :rollback will write rollback_objects to client database.
    * rollback_objects - contains objects attributes before failed update and sends by server. should be specified for :rollback action.
</pre>

<h4>delete-error</h4>

<p>If not handled, local modifications, which were failing on server, will never sync to server again.
So sync will work fine, but nobody will know about these changes.</p>

<pre name="code" class="ruby">RhoConnectClient.on_sync_delete_error( src_name, objects, action )
Model.on_sync_delete_error( objects, action )

    * objects - One or more error objects
    * action - May be :retry - will push delete object operation to server again at next sync.
</pre>

<p>For example:</p>

<pre name="code" class="ruby">    RhoConnectClient.on_sync_create_error( @params['source_name'], 
            @params['server_errors']['create-error'], :delete)

    RhoConnectClient.on_sync_update_error( @params['source_name'], 
            @params['server_errors']['update-error'], :retry)
    RhoConnectClient.on_sync_update_error( @params['source_name'], 
            @params['server_errors']['update-error'], :rollback, @params['server_errors']['update-rollback'] )

    RhoConnectClient.on_sync_delete_error( @params['source_name'], 
            @params['server_errors']['delete-error'], :retry)
</pre>

<h4>unknown-client error</h4>

<p>Unknown client error return by server after resetting server database, removing particular client id from database or any other cases when server cannot find client id(sync server unique id of device).
Note that login session may still exist on server, so in this case client does not have to login again, just create new client id.
Processing of this error contain 2 steps:</p>

<p>When unknown client error is come from server, client should call database_client_reset and start new sync, to register new client id:</p>

<pre name="code" class="ruby">rho_error = Rho::RhoError.new(err_code)

if err_code == Rho::RhoError::ERR_CUSTOMSYNCSERVER
    @msg = @params['error_message']
    end

    @msg = rho_error.message unless @msg and @msg.length &gt; 0

    if rho_error.unknown_client?(@params['error_message'])
        Rhom::Rhom.database_client_reset
        RhoConnectClient.dosync
    end
</pre>

<p>If login session also deleted or expired on the server, then customer has to login again:</p>

<pre name="code" class="ruby">rho_error = Rho::RhoError.new(err_code)

if err_code == Rho::RhoError::ERR_CUSTOMSYNCSERVER
    @msg = @params['error_message']
end

@msg = rho_error.message unless @msg and @msg.length &gt; 0

if err_code == Rho::RhoError::ERR_UNATHORIZED
    WebView.navigate( 
        url_for(
            :action =&gt; :login, 
            :query =&gt; { :msg =&gt; "Server credentials expired!" } 
        )
    )
end
</pre>

<h3>Notification Example</h3>

<p>Here is a simple example of a sync notification method that uses some of the parameters described above:</p>

<pre name="code" class="ruby">def sync_notify
    status = @params['status'] ? @params['status'] : ""
    bulk_sync? = @params['sync_type'] == 'bulk'

    if status == "in_progress"  
        # do nothing

    elsif status == "complete" or status == "ok"
        WebView.navigate Rho::RhoConfig.start_path

    elsif status == "error"

            if @params['server_errors'] &amp;&amp; 
                 @params['server_errors']['create-error']
                    RhoConnectClient.on_sync_create_error( @params['source_name'], 
                            @params['server_errors']['create-error'], :delete)
            end

        err_code = @params['error_code'].to_i
        rho_error = Rho::RhoError.new(err_code)

    if err_code == Rho::RhoError::ERR_CUSTOMSYNCSERVER
            @msg = @params['error_message']
        end

        @msg = rho_error.message unless @msg and @msg.length &gt; 0   

        if rho_error.unknown_client?(@params['error_message'])
            Rhom::Rhom.database_client_reset
            RhoConnectClient.dosync

        elsif err_code == Rho::RhoError::ERR_UNATHORIZED
            WebView.navigate( 
            url_for(
            :action =&gt; :login, 
            :query =&gt; { :msg =&gt; "Server credentials expired!" } 
        )
        )                
        else
            WebView.navigate( 
            url_for(
            :action =&gt; :err_sync, 
            :query =&gt; { :msg =&gt; @msg } 
        )
        )
        end    
    end
end
</pre>

<p><strong>NOTE: If the view was updated using AJAX calls, this mechanism may not work correctly as the view location will not change from one AJAX call to another.  Therefore, you might need to specify the <code>:controller</code> option in WebView.navigate.</strong></p>

<h3>Sync Object Notifications</h3>

<p>The RhoConnectClient can also send a notification when a specific object on the current page has been modified.  This is useful if you have frequently-changing data like feeds or time-lines in your application and want them to update without the user taking any action.</p>

<p>To use object notifications, first set the notification callback in <code>application.rb#initialize</code>:</p>

<pre name="code" class="ruby">class AppApplication &lt; Rho::RhoApplication
     def initialize
        super

        RhoConnectClient.set_objectnotify_url(
        url_for(
        :controller =&gt; "Product",
        :action =&gt; :sync_object_notify
        )
    )
     end
end
</pre>

<p>Next, in your controller action that displays the object(s), add the object notification by passing in a record or collection of records:</p>

<pre name="code" class="ruby">class ProductController &lt; Rho::RhoController

    # GET /Product
    def index
        @products = Product.find(:all)

        add_objectnotify(@products)
        render
    end

    # ...

    def sync_object_notify
        #... do something with notification data ...

    # refresh the current page
        WebView.refresh
        # or call System.execute_js to call JavaScript function which will update list
    end
end
</pre>

<h4>Object Notification Parameters</h4>

<p>The object notification callback receives three arrays of hashes: &ldquo;deleted&rdquo;, &ldquo;updated&rdquo; and &ldquo;created&rdquo;.  Each hash contains values for the keys &ldquo;object&rdquo; and &ldquo;source_id&rdquo; so you can display which records were changed.</p>

<h2>Binary Data and Blob Sync</h2>

<p>Synchronizing images or binary objects between RhoConnect and the RhoConnectClient is declared by having a &lsquo;blob attribute&rsquo; on the <a href="../api/rhom-api">Rhom model</a>. Please see the <a href="../rhoconnect/blob-sync">blob sync section</a> for more information.</p>

<h2>Filtering Datasets with Search</h2>

<p>If you have a large dataset in your back-end service, you don&rsquo;t have to synchronize everything with the RhoConnectClient. Instead you can filter the synchronized dataset using the RhoConnectClient&rsquo;s <code>search</code> function.</p>

<p>Like everything else with the RhoConnectClient, <code>search</code> requires a defined callback which is executed when the <code>search</code> results are retrieved from RhoConnect.</p>

<h3>Using Search</h3>

<p>First, call <code>search</code> from your controller action:</p>

<pre name="code" class="ruby">def search
    page = @params['page'] || 0
    page_size = @params['page_size'] || 10
    Contact.search(
        :from =&gt; 'search',
        :search_params =&gt; { 
        :FirstName =&gt; @params['FirstName'], 
        :LastName =&gt; @params['LastName'], 
        :Company =&gt; @params['Company'] 
    },
        :offset =&gt; page * page_size,
        :max_results =&gt; page_size,
        :callback =&gt; url_for(:action =&gt; :search_callback),
        :callback_param =&gt; ""
    )
    render :action =&gt; :search_wait
end
</pre>

<p>Your callback might look like:</p>

<pre name="code" class="ruby">def search_callback
    status = @params["status"] 
    if (status and status == "ok")
        WebView.navigate( 
        url_for( 
            :action =&gt; :show_page, 
            :query =&gt; @params['search_params']
        ) 
    )
    else
        render :action =&gt; :search_error
    end
end
</pre>

<p><strong>NOTE: Typically you want to forward the original search query <code>@params['search_params']</code> to your view that displays the results so you can perform the same query locally.</strong></p>

<p>Next, the resulting action <code>:show_page</code> will be called.  Here we demonstrate using Rhom&rsquo;s <a href="../api/rhom-api#advanced-queries">advanced find query syntax</a> since we are filtering a very large dataset:</p>

<pre name="code" class="ruby">def show_page
    @contacts = Contact.find(
    :all,
        :conditions =&gt; {
            {
            :func =&gt; 'LOWER',
            :name =&gt; 'FirstName',
            :op =&gt; 'LIKE'
        } =&gt; @params[:FirstName],
            {
            :func =&gt; 'LOWER',
            :name=&gt;'LastName',
            :op=&gt;'LIKE'
        } =&gt; @params[:LastName],
            {
            :func=&gt;'LOWER',
            :name=&gt;'Company',
            :op=&gt;'LIKE'
        } =&gt; @params[:Company],
        }, 
        :op =&gt; 'OR',
        :select =&gt; ['FirstName','LastName', 'Company'],
        :per_page =&gt; page_size,
        :offset =&gt; page * page_size
    )
    render :action =&gt; :show_page
end
</pre>

<p>If you want to stop or cancel the search, return &ldquo;stop&rdquo; in your callback:</p>

<pre name="code" class="ruby">def search_callback
    if(status and status == 'ok')
        WebView.navigate( url_for :action =&gt; :show_page )
    else
        'stop'
    end
end
</pre>

<p>Finally, you will need to implement the <code>search</code> method in your source adapter.  See the <a href="../rhoconnect/source-adapters#source-adapter-api">RhoConnect search method</a> for more details.</p>

<h2>RhoConnectClient API</h2>

<p>Find the full list of methods available in the RhoConnectClient API <a href="https://developer.motorolasolutions.com/docs/DOC-2453">here</a></p>

<h2>Backround synchronization on iOS</h2>

<p>On iOS, if application is put to background, it will be suspended. To allow application finish sync after application goes to background, you can use &lsquo;finish_sync_in_background&rsquo; parameter in <a href="configuration"><code>rhoconfig.txt</code></a>. When this parameter is set to &lsquo;1&rsquo;, if sync is active in the time of background transition ( e.g. started from app_deactivate handler ), application will not be suspended until sync is finished.</p>
