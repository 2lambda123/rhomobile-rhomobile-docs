{"visibility":"place","subject":"Printing API Tutorial","content":{"type":"text/html","text":"<div class='tableofcontents'> </div>\n\n<p>This tutorial covers the use of the Enterprise Browser <a href=\"#api-printing\">Printer API</a> and <a href=\"#api-printingzebra\">PrinterZebra API</a>, as well as some of the typical considerations when working with USB and wireless printers.</p>\n\n<p>The level of instruction in this tutorial is higher than that of other EB tutorials. Completion of the main training module and several additional EB tutorials is recommended (see below). This tutorial enables the sample app from the MBS1018 lesson to print a ticket with a barcode that contains a summary of error data to a printer attached directly to the mobile device.</p>\n\n<p><strong>Note: The code in this tutorial does not implement barcode printing</strong>.</p>\n\n<h2>Prerequisites</h2>\n\n<p>The following are <strong>required</strong> to complete this tutorial:</p>\n\n<ul>\n<li>A background in HTML, CSS and JavaScript coding</li>\n<li>Enterprise Browser installed on a development PC</li>\n<li>A Zebra mobile device and USB cable</li>\n<li>Enterprise Browser installed on the Zebra device</li>\n<li>A supported Zebra or third-party printer</li>\n<li>Appropriate printer drivers installed on the mobile device</li>\n</ul>\n\n\n<p>The following are <strong>strongly recommended</strong>:</p>\n\n<ul>\n<li>Completion of the <a href=\"https://www.youtube.com/watch?v=7llcPIWazkU\">MBS1018 Enterprise Browser Development Fundamentals</a> training (or equivalent knowledge)</li>\n<li>Completion of sample application from the MBS1018 training</li>\n<li>Completion of one or more EB API tutorials (<a href=\"#guide-tutorial-barcode\">Barcode API Tutorial</a> at minimum)</li>\n</ul>\n\n\n<h2>Coding for the Printing API</h2>\n\n<p>Those who&rsquo;ve completed the Barcode tutorial will find the Printer tutorial quite similar. All calls are callback-based and the process follows the Search → Connect → Initialize → Act formula used by other Zebra APIs that work with peripherals.</p>\n\n<h3>Overview</h3>\n\n<p>Condensed into its basic steps, the printing process involves:</p>\n\n<h4>1-Search and Connect:</h4>\n\n<ul>\n<li>Find and enumerate all visible devices (consider USB, BT and Wi-Fi connections)</li>\n<li>Identify the desired output device</li>\n<li>Connect/pair with the device</li>\n</ul>\n\n\n<h4>2-Initialize:</h4>\n\n<ul>\n<li>Check for printer readiness (connection, media, open doors, etc.)</li>\n<li>Initialize printer</li>\n<li>Configure parameters, invoke template, etc.</li>\n</ul>\n\n\n<h4>3-Print:</h4>\n\n<ul>\n<li>Send raw ZPL data, text, images, templates</li>\n<li>Check results and status</li>\n</ul>\n\n\n<h3>Sample app</h3>\n\n<p>The starting point for this tutorial is the sample app from the MBS1018 lesson. If you have not completed that training or didn&rsquo;t save the app, please <a href=\"\">download the sample app</a> now.</p>\n\n<p>To this app, we will add:</p>\n\n<ul>\n<li>A &lsquo;Print&rsquo; button</li>\n<li>The code required to find, connect and print</li>\n</ul>\n\n\n<p>At the end of this tutorial, the resulting application will look like the one below:</p>\n\n<p><img style=\"height:400px\" src=\"images/eb_tutorials/Printing_API_tutorial_02.png\"/></p>\n\n<h3>Preparation</h3>\n\n<p>&mdash;&mdash;&mdash;&mdash;&ndash;>>>>>>> NUMBER THESE STEPS &lt;&lt;&lt;&lt;&lt;&lt;&lt;&mdash;&mdash;&mdash;&mdash;&mdash;</p>\n\n<p>First, let’s add the Print button to our main HTML form. We will also add a placeholder for print status to hold various log messages and alerts during the print. This is very useful to let the user know of printing progress, potential connection errors, lack of paper, etc, when you don’t want to bombard them with alerts and popups. We will add all this right after the quit button.</p>\n\n<pre><code>    :::JavaScript\n    &lt;button onClick=\"EB.Application.quit()\"&gt;Quit&lt;/button&gt;\n&lt;!-- insert the following after the line above --&gt;\n    &lt;button id=”PrintBtn” onClick=\"print_ticket()\"&gt;Print&lt;/button&gt;\n    &lt;div&gt;&lt;span id=\"print_status\"&gt;&lt;/span&gt;&lt;/div&gt;\n&lt;!-- insert the above before the line below --&gt;\n    &lt;/BODY&gt;\n</pre>\n\n<p>The Print APIs requires individual print <code>modules eb.printer.js</code> and <code>eb.printerzebra.js</code>, which are part of the <code>ebapi-modules.js</code> library. This latter library should should already have been included in the app&rsquo;s HTML file:</p>\n\n<pre name=\"code\" class=\"JavaScript\">&lt;script type=\"text/javascript\" charset=\"utf-8\" src=\"ebapi-modules.js\"&gt;&lt;/script&gt;\n</pre>\n\n<p>For more information about how to include API modules, please refer to the <a href=\"#api-printing\">Printing API</a>.</p>\n\n<h3>The main flow</h3>\n\n<p>The key printing process flow fits in four lines of code and can be generally described like this:</p>\n\n<pre><code>    :::JavaScript\n// some prep here, then search all the printers,\n// this can take some time – must use callback:\n\n    EB.PrinterZebra.searchPrinters (&lt;search params&gt;, search_callback)\n\n// to select a printer, consider what was found: 0 or &gt;1,\n// potentially displaying UI to pick and pair with the right one:\n\n    var myPrinter = EB.PrinterZebra.getPrinterByID()\n\n// actually connect, might take time, so has async callback:\n\n    myPrinter.connect(connect_callback)\n\n// finally print, also takes time – use callback\n// prints text, barcodes, images, templates, raw ZPL \n// other command languages, etc.: \n\n    myPrinter.print...(&lt;data&gt;) //printFromFile, printStoredFormat, printRawString, etc\n</pre>\n\n<p>This is the minimal logic required. Let’s implement it and later see what additional features we might need.</p>\n\n<p>Since all the code is callback-based, the actual code structure may be presented as follows (note the nested inline functions). The comments show additional work that logically should be there, but isn’t strictly necessary for the proof-of-concept code:</p>\n\n<pre><code>    :::JavaScript\nfunction print_ticket() {\n/* \nsome prep here, discussed later\n...\nthen search all the printers \n*/\n        EB.PrinterZebra.searchPrinters (&lt;search params here&gt;, function(cb) {    \n    /* \n    do some prep here, such as checking if we have actually found any printers\n    ... \n    then decide if this is the right one and connect\n    note that this callback will be called individually for every printer found this simple code expects just one printer\n    */\n        var myPrinter = EB.PrinterZebra.getPrinterByID(cb.printerID)\n        myPrinter.connect(function(cb){\n    /*\n    check if connection is success \n    check printer state and set any options and parameters\n    upload any images and format files\n    check if the printer is ready, then print\n    ...\n    */\n    // Assumung printer is in ZPL mode, ready and many other addumptinons\n\n        myPrinter.printRawString('^XA^FO20,20^AD^FDTest^XZ',{},function(cb) {\n\n    // update status, display \"please wait \", error processing, etc\n    // can be ignored for PoC code, but a bad idea in production\n            })  \n        })\n    })\n}\n</pre>\n\n<p>This is the key “skeleton” code. Even without everything mentioned in comments, this code will actually print something. Just add the search parameters based on the printer connection type here are the sample search parameter hashes:</p>\n\n<p>TCP/IP (wired or Wi-Fi) with specific address and port:</p>\n\n<pre><code>    :::JavaScript\n{\"deviceAddress\":\"1.2.3.4\",\"devicePort\":6101,\"connectionType\":EB.Printer.CONNECTION_TYPE_TCP}\n</pre>\n\n<p>If the IP address is not specified, the device will sweep the entire /8 (255.0.0.0) subnet, and generally cause a long delay.</p>\n\n<p>Bluetooth with specific MAC Address:</p>\n\n<pre><code>    :::JavaScript\n{\"deviceAddress\":\"00225898D8CB\",\"connectionType\":EB.Printer.CONNECTION_TYPE_BLUETOOTH}\n</pre>\n\n<p>If no BlueTooth MAC address is specified, all devices within range&mdash;headsets, laptops, TVs and printers-–will be returned. EB cannot identify a printing device until after it has paired with one.</p>\n\n<p>Android OS security model does not allow for easy programmatic pairing, so currently user will have to do it manually.</p>\n\n<p>USB:</p>\n\n<pre><code>    :::JavaScript\n{\"connectionType\":EB.Printer.CONNECTION_TYPE_USB}\nUSB Port must be in Host mode before you have started the app.\nLater, check more defaults and parameters in the API Reference and see why you can even use just {}!\n</pre>\n\n<p>More considerations for each connection type are present in the “Remarks” section of API reference.</p>\n\n<p>Here you go! Try it! Chances are – it will print. But chances are, it would not. Why?\nThis code relies on numerous dangerous assumptions, which may be ok for a carefully prepared PoC, but not for real life. Some of these assumptions include:</p>\n\n<ul>\n<li>Only a single printer is connected</li>\n<li>Printer is accessible (paired over BT, etc)</li>\n<li>Printer connection is always successful</li>\n<li>Printer is loaded with media and ready to print</li>\n<li>Media is of the right type, length etc</li>\n<li>Printer is correctly pre-configured to work with the data we want to print (all the settings and options, correct command language and mode used)</li>\n</ul>\n\n\n<p>In addition, this code has more problems, which we will deal with in the next section. Making a pause now would be a good thing.</p>\n\n<h3>Adding flesh to the bones</h3>\n\n<p>In the previous section we have created the “skeleton” code for printing PoC. However, this code has numerous problems, which can be grouped in three categories.</p>\n\n<ul>\n<li>Numerous dangerous assumptions</li>\n<li>Does not reflect the real-life logic and flow</li>\n<li>Hard to manage and inflexible with all the nested inline functions</li>\n</ul>\n\n\n<p>Let’s deal with these problems two and three first. Currently, we have three inline callbacks. This code is not very easy to read, not very flexible and also has a fatal flaw.</p>\n\n<pre><code>    :::JavaScript\nfunction print_ticket() {\n    EB.PrinterZebra.searchPrinters (&lt;search params here&gt;, function(cb) {    \n        var myPrinter = EB.PrinterZebra.getPrinterByID(cb.printerID)\n        myPrinter.connect(function(cb){\n            myPrinter.printRawString('^XA^FO20,20^AD^FDTest^XZ',{},function(cb) {\n            })  \n        })\n    })\n}\n</pre>\n\n<p>The first callback (for searchPrinters) will be called for every printer. If left as is, it will work nicely for a single printer, but how many times will it attempt to connect and print if more than one printer was found? Let’s disentangle everything:</p>\n\n<pre><code>    :::JavaScript\nfunction print_ticket() {\n    EB.PrinterZebra.searchPrinters (&lt;search params here&gt;, search_callback)\n}\n\nfunction search_callback(cb) {  \n    var myPrinter = EB.PrinterZebra.getPrinterByID(cb.printerID)\n    myPrinter.connect(connect_callback)\n}\n\nfunction connect_callback(cb) {\n    myPrinter.printRawString(&lt;string&gt;,{},print_callback)\n}\n\nfunction print_callback(cb) {\n}\n</pre>\n\n<p>Now, let’s think logically and pose a few questions you’ll want to answer when adding printing to your app:</p>\n\n<ul>\n<li><p>Does it make sense to begin searching for printers only after user had pressed “Print”? Isn’t it a bit too late?</p></li>\n<li><p>How long will the search take? How will it affect the user experience?\nShouldn’t I have disabled the Print button when no printers are found (or have done something else, such as displayed an error message or prompted user to select the right printer?)</p></li>\n</ul>\n\n\n<p>In case of a single printer connected via USB cable – none of this is a serious issue. In case of Wi-Fi, Bluetooth or a more universal app, you might want to pause and think.</p>\n\n<p>How can we address these? Probably, a good idea would be to search for printers as soon as the app loads, see how many we found (0, 1, >1) and take action based on this. The action may be disabling the print functionality (if the business process allows it), prompting user to connect a printer, prompting user the select the printer when more than one is found.</p>\n\n<p>In our example we decided to disable the Print button upon page load and only enable it if a suitable printer is found. Here’s what sample code may look like:</p>\n\n<pre><code>    :::JavaScript\n// will hold all the printers found, if we expect more than one\n// global var for simplicity sake\n\n    var printers_array = [] \n\n    function onLoad () { // called by our sample app when the page loads\n\n    // ... other app init code here ...\n\n    EB.PrinterZebra.searchPrinters (&lt;search params&gt;, search_callback)\n\n    // ... other app init code here ...\n}\n\nfunction search_callback(cb) {  // this is triggered for EVERY device found\n    if(cb.status == 'PRINTER_STATUS_SUCCESS' &amp;&amp; cb.printerID != undefined) {\n        v_out('#print_status', \"Found printer: \" + cb.printerID)            \n        var p = EB.PrinterZebra.getPrinterByID(cb.printerID)\n\n        // Only add a device if it has supported printer type. \n        // Here we choose zebra.Check the API reference for more supported types.\n        // of course, this code can do more complex checks\n        if (p.printerType == PRINTER_TYPE_ZEBRA) printers_array.push(p)\n    }\n    else {\n        v_out('#print_status', \"Printer search error: \" + cb.status + “:” + cb.message)\n    }\n}\n</pre>\n\n<p>This code will find all the printers and populate the printers_array with the Printer instances that we need. Now, how would we actually know that the search is over and choose the printer to use? Since the code is async, we will need to specify search timeout as part of parameters, and then trigger an async timed function (using JS standard SetTimeout() call). The default timeout is 30 seconds. We’ll reduce it to 10.</p>\n\n<pre><code>    :::JavaScript\nvar printers_array = []     // will hold all the printers found, if we expect more than one\nvar myPrinter = null    // this will be the printer to use by the app\n\nfunction onLoad () { // called by our sample app when the page loads\n    // ... other app init code here ...\n    $('#PrintBtn').disabled = true\n    v_out('#print_status', \"Searching for printers\")\n    EB.PrinterZebra.searchPrinters ({\"timeout\":10000, &lt;other params&gt;}, search_callback)\n    var PrinterTimeout = setTimeout(process_found_printers, 10500)\n}\n\nfunction process_found_printers() {\n\n    // first, stop the search if it's still on\n    // ideally, the code below should be within the callback of stopSearch()\n    EB.PrinterZebra.stopSearch()\n    // but we want it simple\n\n    if (printers_array.length &lt; 1 ) { // no printers found\n        v_out('#print_status', \"No printers found\")\n        do_something_when_no_printers_found() // your own logic here\n        return\n    }   \n\n    if (printers_array.length &gt; 1) { // multiple printers found\n        v_out('#print_status', \"Multiple printers found\")\n        myPrinter = choose_one_printer_somehow() // ex. let user choose from menu\n    } else { // exactly one printer found\n        v_out('#print_status', \"Printer found\")\n        myPrinter = printers_array[0]\n    }\n    $('#PrintBtn').disabled = false // enable print button\n    v_out('#print_status', \"Connecting to printer \" + myPrinter.ID)     // could specify name or IP instead of ID based on your use case \n    myPrinter.connect(connect_callback)\n}\n</pre>\n\n<p>Now our code actually can search for printers and connect to the chosen one. Once the connection is made (successfully) we can actually enabling printing functionality. Then our print_ticket() function will be simplified to this, which makes a lot more sense:</p>\n\n<pre name=\"code\" class=\"JavaScript\">function print_ticket() { myPrinter.printRawString(&lt;string&gt;,{},print_callback) }\n</pre>\n\n<p>Now we can connect to printer once and print different information from many different parts of our app without any overhead. But is this good enough? We still have a lot of assumptions about the printer state and configuration. We’ll deal with those next.</p>\n\n<h3>Working with the printer</h3>\n\n<p>Now that we have printer found and connected, we want to ensure it’s properly set up and ready to print. Typical tasks and checks here are as follows:</p>\n\n<p>Is printer correctly configured (control language, printer settings, media settings, etc)?</p>\n\n<pre><code>    :::JavaScript\ngetAllProperties(),getProperties(),getProperty()\nsetProperties(),setProperty()\nenumerateSupportedControlLanguages()\nIf printing images or ZPL templates (called “formats”), are those present in the printer? Do we need to push them?\nretrieveFileNames(),retrieveFileNamesWithExtensions()\nstoreImage(), &lt;store format?&gt;\n</pre>\n\n<p>Once printer is all set up and configured, is it ready to print (i.e. door not open, media is there, etc)?</p>\n\n<pre><code>    :::JavaScript\nrequestState()\n</pre>\n\n<p>Is the print attempt successful (print callback)?</p>\n\n<p>Which of these operations do you need to perform just once, and which every time before you print? Most likely, the first two are one-time (unless you actually have to reconfigure the printer for different print tasks), but the state request and status check should be done for every attempt.</p>\n\n<pre><code>    :::JavaScript\n[put the code here one I figure it out]\n</pre>\n\n<p>[WIP] Additional considerations</p>\n\n<p>We decided to leave these out to keep the example simple, but here are some things and tips for you to consider</p>\n\n<p>While working with wireless printers, can you guarantee the connection? Should you use isConnected property and requestState() before every print attempt and reconnect when required?</p>\n\n<p>If deciding to support only one printer, can you guarantee, that you will only find just one?</p>\n\n<p>You can’t pair to BT printer using EB APIs, printer must be paired before (manually, or by other means).</p>\n\n<p>You can check for supported printer types on a specific device via</p>\n\n<pre><code>    :::JavaScript\nenumerateSupportedTypes()\n</pre>\n\n<p>Never assume that printer is set up and ready for work:</p>\n\n<p>Check/set printer mode, operational and media parameters via <code>getProperties()</code> and <code>getProperty()</code>, always set the ones you need.</p>\n\n<p>Check if your templates and images are there via <code>retrieveFileNames()</code>, <code>retrieveFileNamesWithExtensions()</code>,</p>\n\n<p>Can you trust those files (especially, when using highly generic names such as ‘background.png’)? Or should you always send yours (sendFileContents</p>\n\n<p>Are you the only app using the printer? Do you need to disconnect from it?</p>\n\n<p>[WIP] Testing the App\nTap the Enterprise Browser icon on the device. If the device is not yet licensed for Enterprise Browser you will see the following screen:</p>\n\n<pre><code>    :::JavaScript\n  [put the flow here once done]\n</pre>\n\n<h3>Conclusion</h3>\n\n<p>This completes the Enterprise Browser Printing tutorial. For more information, please refer to the <a href=\"#api-printing\">Enterprise Browser Printer API documentation</a>.</p>\n"},"type":"document","minor":true,"parent":"https://developer.motorolasolutions.com/api/core/v3/places/38904"}